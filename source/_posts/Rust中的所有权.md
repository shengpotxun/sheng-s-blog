---
title: Rust中的所有权
tags: Rust
categories: 基础知识
feature: true
cover: 'http://tva1.sinaimg.cn/large/008tudqVgy1h55dlrh99fj339d1jke86.jpg'
abbrlink: 1482cbf3
date: 2022-08-13 19:04:58
---

# 什么是所有权

- rust的核心特性就是所有权
- 所有程序在运行的时候在运行的时候都必须管理它们使用内存的方式
  - 有的语言有垃圾收集机制，在程序运行的时候会不断寻找没有用的内存
  - 而其他语言中程序员必须显式地分配和释放内存（C++）
- Rust采用的是第三种方式来管理内存
  - 内存是通过一个所有权系统来管理的，其中包含一组编译器在编译是检查的规则这种做法不会产生任何运行时开销
  - 所以程序运行的时候，所有权特性不会减慢程序运行的速度

# stack 和 heap

栈内存与堆内存

- 对Rust这种系统级的语言来说，一个值在栈内存还是在堆内存里面堆语言的行为和你要不要做某些事情是有很大影响的
- 堆栈结构不同

## stack栈

- 后入先出
  - 添加数据叫压栈
  - 移除数据叫做弹栈
- 所有存储在栈上的数据必须有已知固定的大小
  - 编译时大小未定的数据或者是运行时大小可能发生变化的数据都必须放在堆上

## heap堆

- 堆对内存的组织性要差一些
  - 当你把数据放入heap的时候，你会请求一定数量的空间
  - 操作系统咋子heap里面找到一块足够大的空间，标记为正在使用，并返回一个指针，也就是这个空间的地址
  - 这个过程叫做在堆上进行分配

- 如何在堆上进行分配
  - 操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配
- 访问堆要比访问栈慢，因为要通过指针才能访问堆内存中的数据
  - 指令在内存中跳转的次数越少，速度就越快
- 栈上的数据存放更加紧密，处理速度会快，堆则相反
- 在堆上面分配空间也是要花时间的

## 函数调用

- 代码调用函数的时候，值被传入函数，变量被送进栈内存，函数结束，值从栈上面弹出

## 所有权存在的原因

- 所有权解决的问题
  - 跟踪嗲码的哪些部分正在使用堆的哪些数据
  - 最小化heap上面的重复数据量
  - 清理heap上的没有用的内存，避免空间不足
- 懂了所有权，就可以不去想栈和堆了
- 管理堆数据就是所有权存在的原因，这也解释了所有权为什么会这样工作

# 所有权规则

- 每个值都有一个变量，这个变量叫**所有者**
- 每个值只能同时具有一个所有者
- 当所有者超出**作用域**的时候，这个值将会被删除

# 变量的作用域

- 作用域就是项目中一个程序的有效范围
- 全局的局部的和别的语言差不多

# 以string类型举例

- string是比较复杂的数据类型
- 它在堆上分配，存储未知大小的文本

```rust
let s = String::from("hello");
```

- 这类字符串（S）是可以被修改的

# 内存与分配

- 在Rust中，一旦走出作用域，内存自动释放
- 这是通过drop函数实现的

# 变量和数据交互的方式：移动

```rust
let x = 5;
let y = x;
```

这两个都是简单的基础数据，所以被塞到栈

```rust
let a = String::from("hello");
let b = a
```

一个String是怎么存在内存里的，首先它的首地址应该放在栈里面，这个指针会指向存放字符串内容的堆，然后栈里面还有字符串的长度、字符串的容量，堆里面也有一块地方存放着字符串的本体，一连串连续的字符

有关String的复制，那实际上是在栈里面重新复制了一份栈内容也就是复制了指向堆的指针，长度和容量，堆里面的内容没有复制

![Screenshot from 2022-08-13 19-42-49.png](http://tva1.sinaimg.cn/mw690/008tudqVgy1h55dk2wyevj30mf0jkadb.jpg)

变量离开作用域的时候，drop就要释放内存，而两个String都会指向同一个内存，这就会导致同一个内容释放两次，会出现bug

- 为了保证内存安全，
  - Rust没有尝试复制被分配的内容而是让S1失效
    - 也就是S1离开作用域的时候不需要释放任何内容
- 为了直观，举个例子

```rust
let s1 = String::from("Hello");
let s2 = s1;
println!("{}",s1);
```

这个会报错的，因为s1已经失效。

像这种不复制堆的内容直接复制栈的内容的复制叫做**浅拷贝**

与之对应的叫做**深拷贝**

这个现象在所有语言中都有，但是在Rust中，为了保证内存安全，会直接让s1失效，只让s2生效，这个叫做**移动**

# 克隆

如果真的想要深拷贝，就必须要用clone方法，给个例子

```rust
let s1=String::from("Hello");
let s2=s1.clone();
println("{}",s1);
```

现在没有报错，它是深拷贝，复制了堆的内容并放在了新的地方，用一个新的指针指向了那里

但是要说明的是clone不是什么时候都可以使用的，这代表了一个Copy的trait，如果一个数据类型或者这个类型的一部分已经实现了Drop trait，那就不能用了

# 复制

当然，以上的内容都是建立在我们必须对堆内存作出规划的情况下，如果我们不需要这么复杂的内容，我们当然可以直接使用“=”而不用考虑这到底是个浅拷贝还是个深拷贝

```rust
let x=5;
let y=x;
println("{}","{}",x,y);
```

上面这个例子肯定是没有问题的。

# 所有权与函数

- 语义上，值传递给函数，要么发生移动，要么发生复制。

```rust
fn main(){
  let s= String::from("hello world");
  movestring(s);
  let x = 5;
  copyint(x);
}

movestring(one_string: String){
  println!("{}",one_string);
}

copyint(one_int: i32){
  println!("{}",one_int);
}
```

上面这个例子中我们把字符串s传到函数里面，这就是一个相当于一个浅拷贝，只是把指针送进去了，这也会导致浅拷贝的问题，在函数结束的时候，这个字符串一起被释放了，对于如果主函数结束的时候再释放一遍，这会导致出问题，所以在Rust中一旦发生了这样的传参数行为，主函数中的变量也会被无效，这相当于发生了一个move传送

而很明显对于int来说这是没有任何影响，因为int不用考虑堆的问题

# 返回值与作用域

- 函数在返回值的过程中同样也会发生所有权的转移

看个例子

```rust
fn main(){
  let s1=get_string();
  let s2=String::from("hello");
  let s3=trans(s2);
}

fn get_string()->String{
  let s4=String::from("hello");
  s4
}

fn trans(one_string:String)->String{
  one_string
}
```

s1的作用域从第二行开始，然后我们要调用函数了，就进去函数里面，发现了s4，s4返回相当于发生了转移，s4被无效了，s1有效，然后函数释放内存，什么都没有发生

自定义一个s2I在第四行被传进了函数里面发生了转移。s2被无效，函数里面有one_string，这个起效了，然后我们返回one_string，又无效了，s3有效，函数结束释放内存，无事发生

main函数结束，s3被释放，其他无事发生

### 总结

- 把变量的值付给别人的时候所有权发生改变
- 一个包含堆的数据离开作用域的时候就会被清理，除非它发生了作用域转移

### 让函数使用值但是不获得所有权

这就与**引用**与**借用**有关
