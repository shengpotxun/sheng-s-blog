---
title: 人工智能导论(2)——搜索算法
tags: 人工智能导论
categories: 课堂笔记
abbrlink: 7de62f9e
date: 2022-09-08 09:51:00
cover: https://tva1.sinaimg.cn/large/008tudqVgy1h5zexoaxrkj32bc12c11z.jpg
---
**考试重点**

- 搜索问题求解的agent
  - 形式化
  - 搜索
  - 执行

通过搜索算法，把感知信息转换为行为

实例：罗马尼亚问题

![](https://tva1.sinaimg.cn/large/008tudqVgy1h5zg7dxpbkj31d20uudmv.jpg)
> 从Arad开车去Bucharest

形式化目标：赶往B城市

执行： 开车路径

# 树搜索算法

基本思路：从初始状态到已知状态，输入是问题，输出是状态，以行动序列的方式返回。

# 定义问题和求解

还是回到罗马尼亚问题，为了解决问题我们抽象出

- 状态：也就是在什么地方我们记为**In(cityname)**
- 初始状态：也就是出发地点，应该是**In(Arad)**
- 目标测试：检测到底有没有到达目的地，也就是当前状态是不是**In(Bucharest)**
- 转移函数：开车函数，记为**Go(cityname)**，描述一个转移过程应该是**Result(In(citybegin),Go(cityend))**
- 路径耗散：加权，在这里应该是走每条路需要消耗的时间

# 无信息搜索算法

为罗马尼亚问题抽象完全之后我们可以进行算法的设计

## 广度优先算法

所谓的广度优先算法本质上是先来先执行算法，当我们得到一个状态时我们将它放入队列，每当出队列的时候对状态进行**目标判断**，如果是**否**我们就把子节点放入队列

先从简单的开始看，父节点A有两个子节点B、C，B指向D、E而C指向F,F为目标状态

|A|
|:-:|

我们把A放入队列，接着把A出队列，在出队列的时候我们会对A进行目标检测，发现不对，这个时候将B、C入队列

|B|C|
|:-:|:-:|

接着B出队列并进行判定，发现不对，D、E入队列

|C|D|E|
|:-:|:-:|:-:|

C出队列而F入队列

**整个过程中表现为，每一层遍历完全之后才会进入下一层。**

这个时候我们可以对广度优先算法进行总结：

- 完备性：会完整遍历无遗漏
- 最优性：不一定是最优解，找到目标状态之后就会停止
- 时间复杂度：顶点个数，全遍历
- 空间复杂度：以队列中最多多少，这里应该指最后一层的数量，其他层都已经出队列的情况，也就是$d^{b-1}$(d子节点数，b层数)

## 一致性算法

是加了比较之后的广度优先算法

在进入队列

## 