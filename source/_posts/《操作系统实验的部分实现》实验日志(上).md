---
title: 《操作系统实验的部分实现》实验日志(上)
tags: 操作系统
categories: 实验日志
descriptions: 操作系统实验的实现——以搭建jiang_os为目标
feature: true
cover: 'http://tva1.sinaimg.cn/large/008tudqVgy1h554mk0s86j315o0ngqmf.jpg'
abbrlink: '83114995'
copyright: false
date: 2022-08-13 14:19:54
---
这是一个实验的记录，原理性的内容没有非常严谨。

参考资料

- [Writing an OS in Rust](https://os.phil-opp.com/vga-text-mode/)
- [BlogOS：ARM v8之旅](https://acmezone.top/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/)
  语言：Rust
  环境：ubuntu20.04

# 安装环境

```
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh//安装rust
source $HOME/.cargo/env//激活rust
rustup default nightly//将rust版本调整为nightly
sudo apt install gcc//安装gcc编译器为编译提供支持
cargo install cargo-binutils rustfilt//安装相关的rust工具
rustup target add aarch64-unknown-none-softfloat//由于我们是arm v8架构，所以要提供arm v8支持
sudo apt-get install qemu qemu-system-arm//安装qemu模拟器方便我们检验自己写的操作系统
sudo apt-get install libncursesw5 libpython2.7 axel//安装python的相关库
axel -n 32 -a https://developer.arm.com/-/media/Files/downloads/gnu-a/10.3-2021.07/binrel/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf.tar.xz
```

# 裸机

为了创建裸机程序，首先我们要用cargo新建一个项目
`cargo new jiang_os`

新建完成

一个裸机应该是独立于现有的操作系统的，也就是不使用所有的rust标准库以及本机的接口，所以首先就要断掉所有的标准库，在main中加入
`#![no_std]`
在弃用了标准库以后，也就不能使用println这样的宏了，所以删掉

然后就是panic报错函数，正常情况下，发生panic的时候会调用panic函数，然而现在的panic已经被我们禁用了，所以我们要自己写一个，

```rust
#panic
//要使用rust core库里面的panic里面的panicinfo，这玩意是没有返回值的

use :: painc::Panicinfo//我要用core里面的panic里面的panicinfo，这个东西用来重写一下panic
fn panic(_info &panicinfo)-> !{
    loop{}
}
```

由于我们禁用了panic,紧跟着用于发生panic时结束错误并释放内存的语言项eh_personality也给我报错所以又要重写一个释放内存的内容，但是这技术要求比较高，我们直接让panic发生的时候把任务终止就行了，不那么麻烦

在我们运行程序之前，会有一个准备工作的过程，这个过程会构建C语言程序的环境并且接上函数的入口点，现在我们已经禁止了所有的标准库，这个过程我们也要手动实现才行，所以我们首先是把预订的入口点main给禁用了加入 `#![no_main]`

入口点怎么写：

- 首先它应该被[no_mangle]标记，以便编译器在编译过后不会随便起一个名字，导致我们没有办法识别到_start
- 然后它应该没有返回值，因为它不会被调用，除非是系统本身
- 我先写个无限循环充数

```rust
[no_mange]
pub extern "C" fn _start () -> !{
    loop
} 
```

我们先前已经把所有的内容都脱离了本机系统，但是链接器在链接的时候会默认使用的C语言环境所以不行，我们要设定链接器脱离C环境，而且还得是arrch为目标平台。

```
//_start.s的代码
.globl _start
.extern LD_STACK_PTR
.section ".text.boot"

_start:
        ldr     x30, =LD_STACK_PTR
        mov     sp, x30
        bl      not_main

.equ PSCI_SYSTEM_OFF, 0x84000002
.globl system_off
system_off:
        ldr     x0, =PSCI_SYSTEM_OFF
        hvc     #0
```

```
//arrch64链接器脚本
ENTRY(_start)
SECTIONS
{
    . = 0x40080000;
    .text.boot : { *(.text.boot) }
    .text : { *(.text) }
    .data : { *(.data) }
    .rodata : { *(.rodata) }
    .bss : { *(.bss) }

    . = ALIGN(8);
    . = . + 0x4000;
    LD_STACK_PTR = .;
}
```

```
{
    "abi-blacklist": [
      "stdcall",
      "fastcall",
      "vectorcall",
      "thiscall",
      "win64",
      "sysv64"
    ],
    "arch": "aarch64",
    "data-layout": "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128",
    "disable-redzone": true,
    "env": "",
    "executables": true,
    "features": "+strict-align,+neon,+fp-armv8",
    "is-builtin": false,
    "linker": "rust-lld",
    "linker-flavor": "ld.lld",
    "linker-is-gnu": true,
    "pre-link-args": {
      "ld.lld": ["-Taarch64-qemu.ld"]
    },
    "llvm-target": "aarch64-unknown-none",
    "max-atomic-width": 128,
    "os": "none",
    "panic-strategy": "abort",
    "relocation-model": "static",
    "target-c-int-width": "32",
    "target-endian": "little",
    "target-pointer-width": "64",
    "vendor": ""
}
```

接下来就是core的问题，平时我们的core是环境提供好的，由于[no_std]之后脱离了主机环境，所以我们必须自己core编译一遍，我查了一下，有两种办法，要么你用xbuild，xbuild自带core的，要么你自己修改一下core的配置

新建一个文件夹.cargo/，然后放config文件

```rust
//config
[unstable]
build-std=["core","compiler_builtins"]
```

接下来是实现引导程序，这个比较复杂，抄的的start.s

现在一个完整的裸机已经构建成功了，虽然运行它还是什么都没有，所以接下来给它实现一点功能，比如把调用VGA字符缓冲区的环节，包装成一个printf宏然后输出我最喜欢的 “hello world”

---

 ***没有一个程序员不喜欢hello world，就好像没有人能拒绝芹菜猪肉饺子——鲁迅***

---

## hello world

{% note primary %}

#### 无效内容，解释了一点VGA原理

我们使用VGA，本来可以用RUST模块的，但是我们用不到别的东西，这样就很多余，就直接建一个文件就好

在前面的构建中，我们已经初步接触到了VGA字符缓冲区，这个字符缓冲区是由二位数组，这个二维数组的每一个16位数字（一般情况下）都会按照格式直接输出到屏幕，下面是一般情况下数字的含义的解读方式

| 数0～7位字 | 含义    |
| ---------- | ------- |
| 0～7位     | ascll码 |
| 8～11      | 前景色  |
| 12～14     | 背景色  |
| 15         | 加亮    |

很明显16位8字节那么我们就要构建一个随时随地都能调用这个VGA字符缓冲区的东西，把他封装起来

到这里，就发现一个问题，什么是缓冲区，怎么读取这个缓冲区，下面解释什么叫做缓冲区

**缓冲区**：就是缓存，缓存是干什么用的，缓存是用来存储即将输出的内容，和即将输入的内容的，为什么要有这么个东西呢，计算机从读写磁盘是非常慢的如果每次都从磁盘开始，效率就比较低，从缓存就快多了，或者我们可以先把内容送到缓存里面，然后直接机械处理就行了，不需要再占用CPU，就快了

那我们这里的字符缓冲区，很明显是一个控制输出的缓存地带，也就是我们把里面的内容改成什么就会机械输出什么内容。那我们怎么访问这个缓存呢，缓存也是内存的一部分，直接访问内存就行了。

<br/>

```rust
// in src/vga_buffer.rs

#[allow(dead_code)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum Color {
    Black = 0,
    Blue = 1,
    Green = 2,
    Cyan = 3,
    Red = 4,
    Magenta = 5,
    Brown = 6,
    LightGray = 7,
    DarkGray = 8,
    LightBlue = 9,
    LightGreen = 10,
    LightCyan = 11,
    LightRed = 12,
    Pink = 13,
    Yellow = 14,
    White = 15,
}
```

解释上面三行的内容，首先就是我们新建了一个Color，rust是一个比较严谨的语言如果你新建变量而不使用这个变量，它会报错，所以这里要让它不报错，就加入一个 `allow(dead_code)`这样就可以不报错了。

Rust语言中的trait是非常重要的概念。在中文里，trait可以翻译为“特征”、“特点”、“特性”等。在Rust中，trait这一个概念承担了多种职责。Rust编程语言内置的derive属性可以快速地替我们的类型加上内置的特性，不过会要求该类型内的字段也都要先实作相同的特性，而且很多时候利用derive属性实作出来的特性并不能达到我们期望的功能。加上这些特性trait之后，它会遵循复制语义，rust在内存管理方面非常严格，对于rust来说有必要对移动语义和复制语义进行区分。

> 语法和文法结构有关，然而语义和按照这个结构所组合的单词符号的意义有关。合理的语法结构并不表明语义是合法的。例如我们常说：我上大学，这个句子是符合语法规则的，也符合语义规则。但是大学上我，虽然符合语法规则，但没有什么意义，所以说是不符合语义的。

repr指定数据类型，这里就是8位二进制数字，其实颜色四个二进制数字就可以全部表示完(16个颜色)，但是rust不支持4位二进制，它最小一字节

rust里面有一个像是穷举的东西叫做enum，这是个**枚举类**，我们用这个东西让颜色和数字对应，这样目的是为了让字符缓冲区认识你在干嘛

用穷举法，直接让所有的颜色对应一个数字

有了颜色，上面表（开头VGA的表）里的前景色和背景色不就肯定能够实现了吗，由于四位表示前景色，四位表示背景色，我们构造统一的一个8位数据类型，这个数据类型四位前景色，后四位背景色，专门用来表示颜色属性

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(transparent)]
struct ColorCode(u8);

impl ColorCode {
    fn new(foreground: Color, background: Color) -> ColorCode {
        ColorCode((background as u8) << 4 | (foreground as u8))
    }
}
```

我们之前一直都设定的都是u8，地址都是8的倍数，我们要保持一致，所以我们就用 `repr(transparent)`来保证我们送进去的是u8,传出来的还是u8

---

Q:保持对齐有什么作用

A:编译原理，内存访问的时候是通过寄存器的整数倍加减控制的

---

颜色搞定，然后还有很多内容，然后我们全部塞进一个大的结构体里面用来详细描述字符缓冲区和字符

在rust里面定义的结构体不会按照顺序在内存里面排列，这就很麻烦，我们直接为我们自己设置的结构体制定内存顺序是“C语言”顺序，这样它就不会乱了，这个结构体里面的内容是前面8位是ascll码，后面8位颜色

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(C)]
struct ScreenChar {
    ascii_character: u8,
    color_code: ColorCode,
}

const BUFFER_HEIGHT: usize = 25;
const BUFFER_WIDTH: usize = 80;

#[repr(transparent)]
struct Buffer {
    chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],
}

```

现在我们有16位也就是两个字节，一个内存就是两个字节，刚刚好不多不少，那么我们现在就要设置字符缓冲区的范围了，这个buffer（缓存）我们设置一个25×80的字符数组，一个字符类型也是16位一个字节，全部都是刚好的

然后还有一个老问题，也就是这个buffer在内存中的对齐问题，我们应该还是u8才对，所以我们设置 `repr(transparent)`上下统一，相较于一般的字符缓冲区，我们的这个它没有bling加亮，对于我们输出一个hello world或者一个五彩斑斓的hello world，这个缓冲区的字符类型应该是够用了，如果你需要一个闪闪发亮的hello world那就不行了

<br/>

> 至此我们构建字符缓冲区已经完毕

接下来我们就得让这个字符缓冲区发挥作用了，越来越靠近我们熟悉的阶段了

```rust
pub struct Writer {
    column_position: usize,
    color_code: ColorCode,
    buffer: &'static mut Buffer,
}

```

搞一个write类型，这个类型得调用之前写出来的缓冲区，把字符写到最后一行，并且在遇到换行符的时候所有字符向上移动一行，然后这串字符可能会有背景颜色和前景色

column_position 变量将跟踪光标在最后一行的位置，然后颜色由color_code来指定，然后又转到我们写的ColorCode上面，这样就决定了前景色和背景色，然后告诉编译器我的缓存buffer是我自己写出来的Buffer，然后因为Rust的特性，我们只能借用这个Buffer，为了确保这个借用是一直都可以用的我们给这个借用加上一个static生命周期，这说明这个借用会在整个程序的运行期间有效

> 那我们要打印字符就要一个打印的方法，写一个为write类型实现的方法

```rust
impl Writer {
    pub fn write_byte(&mut self, byte: u8) {
        match byte {
            b'\n' => self.new_line(),
            byte => {
                if self.column_position >= BUFFER_WIDTH {
                    self.new_line();
                }

                let row = BUFFER_HEIGHT - 1;
                let col = self.column_position;

                let color_code = self.color_code;
                self.buffer.chars[row][col].write(ScreenChar {
                    ascii_character: byte,
                    color_code: color_code,
                });
                self.column_position += 1;
            }
        }
    }

    fn new_line(&mut self) {
        for row in 1..BUFFER_HEIGHT {
            for col in 0..BUFFER_WIDTH {
                let character = self.buffer.chars[row][col].read();
                self.buffer.chars[row - 1][col].write(character);
            }
        }
        self.clear_row(BUFFER_HEIGHT - 1);
        self.column_position = 0;
    }
}
```

这个方法里面要有两个部分，一个是打印字符的部分，另一个是换行的部分，先往里面写两个方法签名**write_byte**和**new_line**，依次来看

- **write_byte**

如果我们输入的是一个换行符，那我们应该什么都不要打印，直接开一个新行，也就是直接调用new_line就行了，然后如果这时候光标位置（colum_position）已经超过了一整行，那同样也要换行调用new_line，除此以外我们每次写入最后一行的光标指向的缓冲区，ascll码字节ScreenChar，然后把光标向后移动一个位置

- **new_line**

这个部分也比较简单，我们直接遍历所有字符然后向上移动一位，很好理解，换行本来是输入向下一行，相对来说就是所有内容向上一行，然而要注意的是我们应该从第1行开始，因为第0行会直接被原第一行覆盖，光标现在所处的这一行应该被清空，清空可以额外写一个方法**clear_row**

```rust
fn clear_row(&mut self, row: usize) {
        let blank = ScreenChar {
            ascii_character: b' ',
            color_code: self.color_code,
        };
        for col in 0..BUFFER_WIDTH {
            self.buffer.chars[row][col].write(blank);
        }
    }
```

然后为了实现字符串输出，我们还是得把多个write_byte整合到一个write_string中

```rust
pub fn write_string(&mut self, s: &str) {
        for byte in s.bytes() {
            match byte {
                // 可以是能打印的 ASCII 码字节，也可以是换行符
                0x20..=0x7e | b'\n' => self.write_byte(byte),
                // 不包含在上述范围之内的字节
                _ => self.write_byte(0xfe),
            }

        }
    }
```

但是我想用格式化宏，因为格式化宏可以不需要每次都实例化

```rust
use core::fmt;

impl fmt::Write for Writer {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        for byte in s.bytes() {
            match byte {
                // 可以是能打印的 ASCII 码字节，也可以是换行符
                0x20..=0x7e | b'\n' => self.write_byte(byte),
                // 不包含在上述范围之内的字节
                _ => self.write_byte(0xfe),
            }

        }
        Ok(())
    }
}
```

这里补充说明一下，为了不让编译器把我们的读写操作优化掉，我们要改变一下screenchar的数据类型，因为编译器不知道我们在操作的是VGA还是是普通的内存RAM，把ScreenChar改成一个Volatile类型，这个类型的读写只能通过自带的write和read

写到这出问题了，**张**和**万**提醒我目标系统是个virt

![a315b81d287d5b3b1baa3812c77e180f.png](http://tva1.sinaimg.cn/large/008tudqVgy1h5550l86y9j303200jq2r.jpg)
virt机器有个pl011设备，这个设备的寄存器在0x9000000开始，virt用pl011作为标准输出，这是因为与PC不同，大部分嵌入式系统默认情况下并不包含VGA设备。没有VGA我直接白写。

我，我全白写啊啊啊啊啊啊啊啊啊

{% endnote %}

***打代码睡大觉，审题眼睛睁不开，看见成绩被吓到，求老师一面网开——汤家凤***

---

virt机器有个pl011设备，这个设备的寄存器在0x9000000开始，virt用pl011作为标准输出，这是因为与PC不同，大部分嵌入式系统默认情况下并不包含VGA设备。没有VGA我直接白写。

串口相较于VGA更加简单一点

先把模块改个名字 `uart_console.rs`

对于串口来说，没有颜色没有缓存，所以Writer结构体没有元素是一个空结构体，更多的起到一个标志的作用，用来标记Write的方法

实现方法的过程也更加简单一点，已知了pl011的寄存器在virt机器中被映射到了0x9000000的内存位置，直接写一个静态指针，然后修改内存的值，由于串口的性质，读写操作比较特殊，比如我可能值已经送走了，此时要求再次读一下串口，值应该是变化的，但是编译器可能优化成相同的值从寄存器里复制一下，所以做一个易失操作，告诉编译器不要优化。打印字符串就更加简单了反复调用打印字节就行

```rust
//往串口寄存器写入字节和字符串进行输出
impl Writer {
    pub fn write_byte(&mut self, byte: u8) {
        const UART0: *mut u8 = 0x0900_0000 as *mut u8;
        unsafe {
            ptr::write_volatile(UART0, byte);
        }
    }

    pub fn write_string(&mut self, s: &str) {
        for byte in s.chars() {
            self.write_byte(byte as u8)
        }
    }
}
```

然后使用RUST自带的格式化宏，给Write带上一个trait，trait是共享方法

```rust
impl core::fmt::Write for Writer {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        self.write_string(s);

        Ok(())
    }
}
```

这里，Ok(()) 属于 Result 枚举类型中的 Ok，包含一个值为 () 的变量。

写到这里已经可以正常输出字符了，但是我每次都必须构建一个Writer的实例，这就很麻烦。我要一个全局接口，为了获得一个全局接口我还要做一些工作

```rust
pub static WRITER: Writer = Writer {};
```

然后我就想了一下，Rust对于静态变量初始化有特殊的要求，一般的我们直接在编译的时候就初始化了，在Rust里面是编译器的常量求值器搞定的，但是这个常量求值器有的时候搞不定就要延迟初始化，但是这里的Write里面是空的肯定是不需要的。

然后我们就要调用这个实例，但是一个静态的实例比较难搞，要么直接可变静态，但是这个会导致数据冲突，同时有一个以上的东西在修改数据，就肯定不行，于是我们就可以找一些本身提供可变的类型。要定义同步的内部可变性，我们往往使用标准库提供的互斥锁类 Mutex

> 互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。
>
> 注意: 互斥锁是多个线程一起去抢，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。

但是我们这里是没有阻塞的，因为我们写的简单操作系统还没有这个东西，还有一种较为基础的互斥锁实现方式——自旋锁（spinlock）。自旋锁并不会调用阻塞逻辑，而是在一个小的无限循环中反复尝试获得这个锁，也因此会一直占用 CPU 时间，直到互斥锁被它的占用者释放。

为了使用自旋的互斥锁，我们添加 spin包 到项目的依赖项列表：

```rust
# in Cargo.toml
[dependencies]
spin = "0.9.2"
```

```rust
pub static WRITER: Mutex<Writer> = Mutex::new(Writer{}）
```

有了全局的实例，就能实现全局的宏

标准库里面的println!和print!

```rust
#[macro_export]
macro_rules! println {
    () => (print!("\n"));
    ($($arg:tt)*) => (print!("{}\n", format_args!($($arg)*)));
}

#[macro_export]
macro_rules! print {
    ($($arg:tt)*) => ($crate::io::_print(format_args!($($arg)*)));
}
```

println!有两个规则，一个是没有参数输入的时候就换行，另一个是打印字符串会直接调用print!，然后补上一个换行。

print!这个宏将扩展为一个对 io 模块中 _print 函数的调用，然后我们稍微改一下，指向我们自己写的模块，里面的_print函数

<br/>

#[macro_export] 属性让整个包（crate）和基于它的包都能访问这个宏，而不仅限于定义它的模块（module）。

```rust
/// Like the `print!` macro in the standard library, but prints to the VGA text buffer.
#[macro_export]
macro_rules! print {
    ($($arg:tt)*) => ($crate::uart_console::_print(format_args!($($arg)*)));
}

/// Like the `println!` macro in the standard library, but prints to the VGA text buffer.
#[macro_export]
macro_rules! println {
    () => ($crate::print!("\n"));
    ($($arg:tt)*) => ($crate::print!("{}\n", format_args!($($arg)*)));
}

#[doc(hidden)]
pub fn _print(args: fmt::Arguments) {
    use core::fmt::Write;

    WRITER.lock().write_fmt(args).unwrap();
}
```

现在已经可以直接使用

# 从放弃轮询到写不出中断

---

***人类获得了火焰从猿走向人，底层程序猿获得了中断走向猴子都不如——阿基米德***

---

现代操作系统是基于中断的，写到这里我们也到了向这个简单操作系统中加入中断的时候了，在写之我们得查看设备手册获得必要的知识

## 基础知识

首先我们用的是armv8架构中断控制器是GICv2

GIC对一个中断源的处理过程包含Inactive, Pending, Active和Active and Pending四种状态。

- **Inactive**:没有触发
- **Pending**：待处理，IAR寄存器标志为1
- **Active**：读取IAR，并且将IAR清零，处理器回复ACK信号给GIC
- **Active and pending**：第二个中断来了，前一个还在处理

GIC中断控制器定义了3种中断

- SGI（Software Generated Interrupt）
  - 中断号是0-15之间
  - 用于core之间相互通信，由软件触发的中断，也可以称为IPI中断
- PPI（Private Perpheral Interrupt）
  - 中断号在16-31之间
  - 此类中断是每个core私有的，只用于当前core处理一些业务时使用，比如每个core上有一个tick中断，用于进程调度使用
- SPI（Shared Perpheral Interrupt）
  - 中断号在32-1020之间
  - 此类中断是由外设触发的中断信号产线，比如touch的触摸屏中断等

### Distributor仲裁器

所有GICD开头的都是 distributor的寄存器，用来实现不同的功能

仲裁器的主要作用是对中断优先级排序，以及将SPI和PPI中断分发到Redistributor和CPU-Interface模块，仲裁器对应的寄存器为GICD_CTLR

- GICD_ISENABLER:中断使能，1bit关联一个中断
- GICD_ICENABLER：中断禁止，1bit关联一个中断
- GICD_ICPENDR：修改中断pending状态，1bit关联一个中断
- GICD_IPRIORITYR：设置中断优先级，字节有效一个字节对应一个中断
- GICD_ICFGR：设置中断触发类型

### CPU interfacce

然后CPU interface是用来判断优先级并决定是否向CPU传递

GICC_CTLR是开头也是一个标志位

功能

- GICC_PMR：进行优先级判定，只有优先级比这个寄存器里面的值大才能向CPU传递
- GICC_BPR：对优先级规则的细化

获得以上知识之后我们就可以开始写了

## 过程

首先是新建一个模块

`interrupts.rs`

然后向里面写入各个寄存器的内存地址映像以及必要的常量数据

```rust
use core::ptr;

// GICD和GICC寄存器内存映射后的起始地址
const GICD_BASE: u64 = 0x08000000;
const GICC_BASE: u64 = 0x08010000;

// Distributor
const GICD_CTLR: *mut u32 = (GICD_BASE + 0x0) as *mut u32;//仲裁器
const GICD_ISENABLER: *mut u32 = (GICD_BASE + 0x0100) as *mut u32;//中断使能，1bit关联一个中断
const GICD_ICENABLER: *mut u32 = (GICD_BASE + 0x0180) as *mut u32;//中断禁止，1bit关联一个中断
const GICD_ICPENDR: *mut u32 = (GICD_BASE + 0x0280) as *mut u32;//修改中断pending状态，1bit关联一个中断
const GICD_IPRIORITYR: *mut u32 = (GICD_BASE + 0x0400) as *mut u32;//设置中断优先级，字节有效一个字节对应一个中断
const GICD_ICFGR: *mut u32 = (GICD_BASE + 0x0c00) as *mut u32;//设置中断触发类型

const GICD_CTLR_ENABLE: u32 = 1;  /* Enable GICD */
const GICD_CTLR_DISABLE: u32 = 0;     /* Disable GICD */
const GICD_ISENABLER_SIZE: u32 = 32;
const GICD_ICENABLER_SIZE: u32 = 32;
const GICD_ICPENDR_SIZE: u32 = 32;
const GICD_IPRIORITY_SIZE: u32 = 4;
const GICD_IPRIORITY_BITS: u32 = 8;
const GICD_ICFGR_SIZE: u32 = 16;
const GICD_ICFGR_BITS: u32 = 2;

// CPU Interface
const GICC_CTLR: *mut u32 = (GICC_BASE + 0x0) as *mut u32;//cpu interface的寄存器起始
const GICC_PMR: *mut u32 = (GICC_BASE + 0x0004) as *mut u32;//进行优先级判定，只有优先级比这个寄存器里面的值大才能向CPU传递
const GICC_BPR: *mut u32 = (GICC_BASE + 0x0008) as *mut u32;//对优先级规则的细化

const GICC_CTLR_ENABLE: u32 = 1;
const GICC_CTLR_DISABLE: u32 = 0;
// Priority Mask Register. interrupt priority filter, Higher priority corresponds to a lower Priority field value.
const GICC_PMR_PRIO_LOW: u32 = 0xff;
// The register defines the point at which the priority value fields split into two parts,
// the group priority field and the subpriority field. The group priority field is used to
// determine interrupt preemption. NO GROUP.
const GICC_BPR_NO_GROUP: u32 = 0x00;
```

接下来就要实现方法函数

```rust
use core::arch::asm;
pub fn init_gicv2() {
    // 初始化Gicv2的distributor和cpu interface
    // 禁用distributor和cpu interface后进行相应配置
    unsafe {
        ptr::write_volatile(GICD_CTLR, GICD_CTLR_DISABLE);//禁用distributor
        ptr::write_volatile(GICC_CTLR, GICC_CTLR_DISABLE);//禁用interface
        ptr::write_volatile(GICC_PMR, GICC_PMR_PRIO_LOW);//修改优先级
        ptr::write_volatile(GICC_BPR, GICC_BPR_NO_GROUP);//
    }

    // 启用distributor和cpu interface
    unsafe {
        ptr::write_volatile(GICD_CTLR, GICD_CTLR_ENABLE);//重新启用d
        ptr::write_volatile(GICC_CTLR, GICC_CTLR_ENABLE);//重新启用c
    }
    // 电平触发
    const ICFGR_LEVEL: u32 = 0;
    // 时钟中断号30
    const TIMER_IRQ: u32 = 30;
    set_config(TIMER_IRQ, ICFGR_LEVEL); //电平触发
    set_priority(TIMER_IRQ, 0); //优先级设定
    clear(TIMER_IRQ); //清除时钟中断请求
    enable(TIMER_IRQ); //使能中断
  
    //配置timer
    unsafe {
        asm!("mrs x1, CNTFRQ_EL0"); //读取系统频率
        asm!("msr CNTP_TVAL_EL0, x1");  //设置定时寄存器
        asm!("mov x0, 1");
        asm!("msr CNTP_CTL_EL0, x0"); //enable=1, imask=0, istatus= 0,
        asm!("msr daifclr, #2");
    }
}

// 使能中断号为interrupt的中断
pub fn enable(interrupt: u32) {
    unsafe {
        ptr::write_volatile(
            GICD_ISENABLER.add((interrupt / GICD_ISENABLER_SIZE) as usize),
            1 << (interrupt % GICD_ISENABLER_SIZE)
        );
    }
}

// 禁用中断号为interrupt的中断
pub fn disable(interrupt: u32) {
    unsafe {
        ptr::write_volatile(
            GICD_ICENABLER.add((interrupt / GICD_ICENABLER_SIZE) as usize),
            1 << (interrupt % GICD_ICENABLER_SIZE)
        );
    }
}

// 清除中断号为interrupt的中断
pub fn clear(interrupt: u32) {
    unsafe {
        ptr::write_volatile(
            GICD_ICPENDR.add((interrupt / GICD_ICPENDR_SIZE) as usize),
            1 << (interrupt % GICD_ICPENDR_SIZE)
        );
    }
}

// 设置中断号为interrupt的中断的优先级为priority
pub fn set_priority(interrupt: u32, priority: u32) {
    let shift = (interrupt % GICD_IPRIORITY_SIZE) * GICD_IPRIORITY_BITS;
    unsafe {
        let addr: *mut u32 = GICD_IPRIORITYR.add((interrupt / GICD_IPRIORITY_SIZE) as usize);
        let mut value: u32 = ptr::read_volatile(addr);
        value &= !(0xff << shift);
        value |= priority << shift;
        ptr::write_volatile(addr, value);
    }
}

// 设置中断号为interrupt的中断的属性为config
pub fn set_config(interrupt: u32, config: u32) {
    let shift = (interrupt % GICD_ICFGR_SIZE) * GICD_ICFGR_BITS;
    unsafe {
        let addr: *mut u32 = GICD_ICFGR.add((interrupt / GICD_ICFGR_SIZE) as usize);
        let mut value: u32 = ptr::read_volatile(addr);
        value &= !(0x03 << shift);
        value |= config << shift;
        ptr::write_volatile(addr, value);
    }
}
```

- 初始化
- 使能
- 停止
- 清零
- 设置优先级
- 设置属性

```rust
use core::arch::global_asm;
global_asm!(include_str!("exceptions.s"));//定义错误的内容

#[repr(C)]//C语言格式对齐
pub struct ExceptionCtx {//保存寄存器的状态和值
    regs: [u64; 30],
    elr_el1: u64,
    spsr_el1: u64,
    lr: u64,
}
//对各种的名称的引用，具体信息放在exception
const EL1_SP0_SYNC: &'static str = "EL1_SP0_SYNC";
const EL1_SP0_IRQ: &'static str = "EL1_SP0_IRQ";
const EL1_SP0_FIQ: &'static str = "EL1_SP0_FIQ";
const EL1_SP0_ERROR: &'static str = "EL1_SP0_ERROR";
const EL1_SYNC: &'static str = "EL1_SYNC";
const EL1_IRQ: &'static str = "EL1_IRQ";
const EL1_FIQ: &'static str = "EL1_FIQ";
const EL1_ERROR: &'static str = "EL1_ERROR";
const EL0_SYNC: &'static str = "EL0_SYNC";
const EL0_IRQ: &'static str = "EL0_IRQ";
const EL0_FIQ: &'static str = "EL0_FIQ";
const EL0_ERROR: &'static str = "EL0_ERROR";
const EL0_32_SYNC: &'static str = "EL0_32_SYNC";
const EL0_32_IRQ: &'static str = "EL0_32_IRQ";
const EL0_32_FIQ: &'static str = "EL0_32_FIQ";
const EL0_32_ERROR: &'static str = "EL0_32_ERROR";

// 调用我们的print!宏打印异常信息，你也可以选择打印异常发生时所有寄存器的信息
fn catch(ctx: &mut ExceptionCtx, name: &str) {
    crate::print!(
        "\n  \
        {} @ 0x{:016x}\n\n ",
        name,
        ctx.elr_el1,
    );
}

#[no_mangle]//不改变函数名称
unsafe extern "C" fn el1_sp0_sync(ctx: &mut ExceptionCtx) {
    catch(ctx, EL1_SP0_SYNC);
}

#[no_mangle]
unsafe extern "C" fn el1_sp0_irq(ctx: &mut ExceptionCtx) {
    catch(ctx, EL1_SP0_IRQ);
}

#[no_mangle]
unsafe extern "C" fn el1_sp0_fiq(ctx: &mut ExceptionCtx) {
    catch(ctx, EL1_SP0_FIQ);
}

#[no_mangle]
unsafe extern "C" fn el1_sp0_error(ctx: &mut ExceptionCtx) {
    catch(ctx, EL1_SP0_ERROR);
}

#[no_mangle]
unsafe extern "C" fn el1_sync(ctx: &mut ExceptionCtx) {
    catch(ctx, EL1_SYNC);
}

#[no_mangle]
unsafe extern "C" fn el1_irq(ctx: &mut ExceptionCtx) {
    catch(ctx, EL1_IRQ);
}

#[no_mangle]
unsafe extern "C" fn el1_fiq(ctx: &mut ExceptionCtx) {
    catch(ctx, EL1_FIQ);
}

#[no_mangle]
unsafe extern "C" fn el1_error(ctx: &mut ExceptionCtx) {
    catch(ctx, EL1_ERROR);
}

#[no_mangle]
unsafe extern "C" fn el0_sync(ctx: &mut ExceptionCtx) {
    catch(ctx, EL0_SYNC);
}

#[no_mangle]
unsafe extern "C" fn el0_irq(ctx: &mut ExceptionCtx) {
    catch(ctx, EL0_IRQ);
}

#[no_mangle]
unsafe extern "C" fn el0_fiq(ctx: &mut ExceptionCtx) {
    catch(ctx, EL0_FIQ);
}

#[no_mangle]
unsafe extern "C" fn el0_error(ctx: &mut ExceptionCtx) {
    catch(ctx, EL0_ERROR);
}

#[no_mangle]
unsafe extern "C" fn el0_32_sync(ctx: &mut ExceptionCtx) {
    catch(ctx, EL0_32_SYNC);
}

#[no_mangle]
unsafe extern "C" fn el0_32_irq(ctx: &mut ExceptionCtx) {
    catch(ctx, EL0_32_IRQ);
}

#[no_mangle]
unsafe extern "C" fn el0_32_fiq(ctx: &mut ExceptionCtx) {
    catch(ctx, EL0_32_FIQ);
}

#[no_mangle]
unsafe extern "C" fn el0_32_error(ctx: &mut ExceptionCtx) {
    catch(ctx, EL0_32_ERROR);
}
```

为了定义错误的情况我们构建异常向量表，具体信息放在exceptions里面

而具体内容是在手册上，根据老师的内容写了

```rust
// SPDX-License-Identifier: MIT OR Apache-2.0
//
// Copyright (c) 2018-2021 Andre Richter <andre.o.richter@gmail.com>

.extern el1_sp0_sync
.extern el1_sp0_irq
.extern el1_sp0_fiq
.extern el1_sp0_error
.extern el1_sync
.extern el1_irq
.extern el1_fiq
.extern el1_error
.extern el0_sync
.extern el0_irq
.extern el0_fiq
.extern el0_error
.extern el0_32_sync
.extern el0_32_irq
.extern el0_32_fiq
.extern el0_32_error

//--------------------------------------------------------------------------------------------------
// Definitions
//--------------------------------------------------------------------------------------------------

/// Call the function provided by parameter `\handler` after saving the exception context. Provide
/// the context as the first parameter to '\handler'.
.equ CONTEXT_SIZE, 264

.section .text.exceptions

.macro EXCEPTION_VECTOR handler
    sub sp, sp, #CONTEXT_SIZE

// store general purpose registers
    stp x0, x1, [sp, #16 * 0]
    stp x2, x3, [sp, #16 * 1]
    stp x4, x5, [sp, #16 * 2]
    stp x6, x7, [sp, #16 * 3]
    stp x8, x9, [sp, #16 * 4]
    stp x10, x11, [sp, #16 * 5]
    stp x12, x13, [sp, #16 * 6]
    stp x14, x15, [sp, #16 * 7]
    stp x16, x17, [sp, #16 * 8]
    stp x18, x19, [sp, #16 * 9]
    stp x20, x21, [sp, #16 * 10]
    stp x22, x23, [sp, #16 * 11]
    stp x24, x25, [sp, #16 * 12]
    stp x26, x27, [sp, #16 * 13]
    stp x28, x29, [sp, #16 * 14]

// store exception link register and saved processor state register
    mrs x0, elr_el1
    mrs x1, spsr_el1
    stp x0, x1, [sp, #16 * 15]

// store link register which is x30
    str x30, [sp, #16 * 16]
    mov x0, sp

// call exception handler
    bl \handler

// exit exception
    b .exit_exception
.endm


//--------------------------------------------------------------------------------------------------
// Private Code
//--------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// The exception vector table.
//------------------------------------------------------------------------------
/** When an exception occurs, the processor must execute handler code that corresponds to the exception.
The location in memory where the handler is stored is called the exception vector. In the ARM architecture,
exception vectors are stored in a table, called the exception vector table.

Each Exception level has its own vector table, that is, there is one for each of EL3, EL2, and EL1. The table contains
instructions to be executed, rather than a set of addresses. These would normally be branch instructions that direct the
core to the full exception handler.

The exception vector table for EL1, for example, holds instructions for handling all types of exception that can occur at EL1,
Vectors for individual exceptions are at fixed offsets from the beginning of the table. The virtual address of each table base
is set by the Vector Based Address Registers: VBAR_EL3, VBAR_EL2 and VBAR_EL1.

Each entry in the vector table is 16 instructions long (in ARMv7-A and AArch32, each entry is only 4 bytes). This means that in
AArch64 the top-level handler can be written directly in the vector table.

The base address is given by VBAR_ELn and each entry has a defined offset from this base address. Each table has 16 entries,
with each entry being 128 bytes (32 instructions) in size. The table effectively consists of 4 sets of 4 entries. Which entry
is used depends on several factors:

The type of exception (SError, FIQ, IRQ, or Synchronous)
If the exception is being taken at the same Exception level, the stack pointer to be used (SP0 or SPn)
If the exception is being taken at a lower Exception level, the Execution state of the next lower level (AArch64 or AArch32).
*/



.section .text.exceptions_vector_table
// Export a symbol for the Rust code to use.
.globl exception_vector_table
exception_vector_table:

.org 0x0000
    EXCEPTION_VECTOR el1_sp0_sync

.org 0x0080
    EXCEPTION_VECTOR el1_sp0_irq

.org 0x0100
    EXCEPTION_VECTOR el1_sp0_fiq

.org 0x0180
    EXCEPTION_VECTOR el1_sp0_error

.org 0x0200
    EXCEPTION_VECTOR el1_sync

.org 0x0280
    EXCEPTION_VECTOR el1_irq

.org 0x0300
    EXCEPTION_VECTOR el1_fiq

.org 0x0380
    EXCEPTION_VECTOR el1_error

.org 0x0400
    EXCEPTION_VECTOR el0_sync

.org 0x0480
    EXCEPTION_VECTOR el0_irq

.org 0x0500
    EXCEPTION_VECTOR el0_fiq

.org 0x0580
    EXCEPTION_VECTOR el0_error

.org 0x0600
    EXCEPTION_VECTOR el0_32_sync

.org 0x0680
    EXCEPTION_VECTOR el0_32_irq

.org 0x0700
    EXCEPTION_VECTOR el0_32_fiq

.org 0x0780
    EXCEPTION_VECTOR el0_32_error

.org 0x0800

.exit_exception:
// restore link register
    ldr x30, [sp, #16 * 16]

// restore exception link register and saved processor state register
    ldp x0, x1, [sp, #16 * 15]
    msr elr_el1, x0
    msr spsr_el1, x1

// restore general purpose registers
    ldp x28, x29, [sp, #16 * 14]
    ldp x26, x27, [sp, #16 * 13]
    ldp x24, x25, [sp, #16 * 12]
    ldp x22, x23, [sp, #16 * 11]
    ldp x20, x21, [sp, #16 * 10]
    ldp x18, x19, [sp, #16 * 9]
    ldp x16, x17, [sp, #16 * 8]
    ldp x14, x15, [sp, #16 * 7]
    ldp x12, x13, [sp, #16 * 6]
    ldp x10, x11, [sp, #16 * 5]
    ldp x8, x9, [sp, #16 * 4]
    ldp x6, x7, [sp, #16 * 3]
    ldp x4, x5, [sp, #16 * 2]
    ldp x2, x3, [sp, #16 * 1]
    ldp x0, x1, [sp, #16 * 0]

// restore stack pointer
    add sp, sp, #CONTEXT_SIZE
    eret
```

为了引入异常向量表在初始化也就是start.s中加入以下代码来载入

```
// ······
        mov     sp, x30

        // Initialize exceptions
        ldr     x0, =exception_vector_table
        msr     vbar_el1, x0
        isb

        bl      not_main
// ······
```

同样为了连接器能够识别并链接异常向量表要在ld文件中加入

```
// ······
    .text.boot : { *(.text.boot) }
    .text :
    {
        KEEP(*(.text.boot))
        *(.text.exceptions)
        . = ALIGN(4096); /* align for exceptions_vector_table*/
        *(.text.exceptions_vector_table)
        *(.text)
    }
    .data : { *(.data) }
// ······
```

编辑src/main.rs，引入interrupts.rs模块，并在not_main()函数中注释掉之前的hello world输出代码，调用init_gicv2()函数

## 调试

`cargo build && qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -S -s`

```
aarch64-none-elf-gdb target/aarch64-unknown-none-softfloat/debug/rui_armv8_os
target remote localhost:1234
b not_main
```

运行到interrupts::init_gicv2();语句之前。

`n`

查看0x08000100地址中的值，

`x/t 0x08000100`

# 为了消除警告做进一步的修改

虽然到这里我们可以成功编译运行，但是很明显是很有问题的，就是很多警告，有警告看上去就很危险，这是我们不希望的，于是我借鉴了一些别人的操作进行了一定的修改

---

***能跑就行，程序和你其中一个能跑就行——约尔·佛杰***

---

在 `interupts.rs`中我们为了和实际的硬件相联系，于是穷举了所有的情况并且设置了很多的常数以及指针，但是这些内容并不是随时都用到的，在这些值没有使用的时候称为**dead code**就没有用过，在rust中认为申明了不用是一种可耻的行为于是会产生警告，为此我们在 `main.rs`中加入

```rust
#![allow(dead_code)] // 忽略dead_code
```

这样我们的警告就已经消失的差不多了，再来看第二个问题就是说，我们的时钟中断就仅仅中断了一次，没有实现定时中断的效果，为了实现这个效果我找别人问了一下~~抄了一下~~在 `init_gicv2()`函数后面加上了

```rust
loop {
    unsafe {
        asm!("mrs x0, CNTPCT_EL0"); // 系统计数器
        asm!("mrs x0, CNTP_CTL_EL0"); // 控制计数器
        asm!("mrs x0, CNTP_TVAL_EL0"); // 定时计数器
        asm!("mrs x0, CNTP_CVAL_EL0"); // 比较计数器
        asm!("wfi"); // Wait for Interrupt 等待中断，下一次中断发生前都停止在此处
    }
}
```

还是不行，本来应该行的，就是发现做完第一次之后发生了阻塞，不懂是不是因为无限循环 `loop`最后的解决方法是

在 `config.toml`里面改成

```rust
[unstable]
build-std = ["core", "compiler_builtins"] 

[build]
target = "aarch64-unknown-none-softfloat"
rustflags = ["-C","link-arg=-Taarch64-qemu.ld", "-C", "target-cpu=cortex-a53", "-D", "warnings"]
```

这样就可以了，与此同时对于我们输出中断类型的方式也要做一点修改

```rust
//interupts.rs
// 调用我们的print!宏打印异常信息，你也可以选择打印异常发生时所有寄存器的信息
fn catch(ctx: &mut ExceptionCtx, name: &str) {
    crate::print!("{}\n", name);
}
```

最终我们会发现显示屏上不断输出 `EL1_IRQ`

对于**ARM架构**的芯片来说，其中的时钟延时中断是由内置的比较寄存器来实现的，当时钟计数超过了这个比较寄存器就会发生定时中断，为了达到这个效果我们要在 `EL1_IRQ`(一级中断)里面进行一定的设置

```rust
#[no_mangle]
unsafe extern "C" fn el1_sp0_irq(ctx: &mut ExceptionCtx) {
    catch(ctx, EL1_SP0_IRQ);

    asm!("mrs x1, CNTFRQ_EL0");
    asm!("msr CNTP_TVAL_EL0, x1");
}
```

也就是说在实现一级中断的时候要向已经清零的比较寄存器里面再次写入我们希望的时间间隔，这样就可以产生延时中断了

## 重构代码

***优化代码，重构一下，麻烦了自己……，也不会方便他人，嗯，就是麻烦了自己——爱德华·艾力克***

---

由于我们在之前为了实现中断，我们写了很多的寄存器映射以及常数以及指针以及字符串，这个比较绕，而且容易出错，于是我们对代码进行一遍重构

在 `Cargo.toml`中加入新的依赖 `tock-registers = "0.7.0"`

这个东西官网是这么描述的

> Provides efficient mechanisms to express and use type-checked memory mapped registers and bitfields.

<br/>

# 有输出就有输入

我们要进一步完善我们的嵌入式操作系统virt，终于到了实现输入的时候

首先我们应该明确在我们的操作系统中很多的内容都应该是和中断相关的，很显然这里也是如此，简单来说我们需要实现一个输入中断

这个过程应该是分为两部分的，一方面我们要接收数据，另一方面我们要把接受到的数据打印到屏幕上面来告诉我们，这个数据确实已经被接受到了

在之前我们实现打印的过程中，我们了解到vert的pl011串口，并且通过直接修改内存地址映射的方式实现了打印，QEMU的virt机器默认没有键盘作为输入设备，但当我们执行QEMU使用-nographic参数（Disable graphical output and redirect serial I/Os to console）时QEMU会将串口重定向到控制台，因此我们可以使用UART(异步收发传输器)作为输入设备。

第一步就是要把所有的设备寄存器映射到内存地址空间，

```rust
use tock_registers::{registers::{ReadOnly, ReadWrite, WriteOnly}, register_bitfields, register_structs};

pub const PL011REGS: *mut PL011Regs = (0x0900_0000) as *mut PL011Regs;

register_bitfields![
    u32,

    pub UARTDR [
        DATA OFFSET(0) NUMBITS(8) []
    ],
    /// Flag Register
    pub UARTFR [
        /// Transmit FIFO full. The meaning of this bit depends on the
        /// state of the FEN bit in the UARTLCR_ LCRH Register. If the
        /// FIFO is disabled, this bit is set when the transmit
        /// holding register is full. If the FIFO is enabled, the TXFF
        /// bit is set when the transmit FIFO is full.
        TXFF OFFSET(6) NUMBITS(1) [],

        /// Receive FIFO empty. The meaning of this bit depends on the
        /// state of the FEN bit in the UARTLCR_H Register. If the
        /// FIFO is disabled, this bit is set when the receive holding
        /// register is empty. If the FIFO is enabled, the RXFE bit is
        /// set when the receive FIFO is empty.
        RXFE OFFSET(4) NUMBITS(1) []
    ],

    /// Integer Baud rate divisor
    pub UARTIBRD [
        /// Integer Baud rate divisor
        IBRD OFFSET(0) NUMBITS(16) []
    ],

    /// Fractional Baud rate divisor
    pub UARTFBRD [
        /// Fractional Baud rate divisor
        FBRD OFFSET(0) NUMBITS(6) []
    ],

    /// Line Control register
    pub UARTLCR_H [
        /// Parity enable. If this bit is set to 1, parity checking and generation
        /// is enabled, else parity is disabled and no parity bit added to the data frame.
        PEN OFFSET(1) NUMBITS(1) [
            Disabled = 0,
            Enabled = 1
        ],
        /// Two stop bits select. If this bit is set to 1, two stop bits are transmitted
        /// at the end of the frame.
        STP2 OFFSET(3) NUMBITS(1) [
            Stop1 = 0,
            Stop2 = 1
        ],
        /// Enable FIFOs.
        FEN OFFSET(4) NUMBITS(1) [
            Disabled = 0,
            Enabled = 1
        ],

        /// Word length. These bits indicate the number of data bits
        /// transmitted or received in a frame.
        WLEN OFFSET(5) NUMBITS(2) [
            FiveBit = 0b00,
            SixBit = 0b01,
            SevenBit = 0b10,
            EightBit = 0b11
        ]
    ],

    /// Control Register
    pub UARTCR [
        /// Receive enable. If this bit is set to 1, the receive
        /// section of the UART is enabled. Data reception occurs for
        /// UART signals. When the UART is disabled in the middle of
        /// reception, it completes the current character before
        /// stopping.
        RXE    OFFSET(9) NUMBITS(1) [
            Disabled = 0,
            Enabled = 1
        ],

        /// Transmit enable. If this bit is set to 1, the transmit
        /// section of the UART is enabled. Data transmission occurs
        /// for UART signals. When the UART is disabled in the middle
        /// of transmission, it completes the current character before
        /// stopping.
        TXE    OFFSET(8) NUMBITS(1) [
            Disabled = 0,
            Enabled = 1
        ],

        /// UART enable
        UARTEN OFFSET(0) NUMBITS(1) [
            /// If the UART is disabled in the middle of transmission
            /// or reception, it completes the current character
            /// before stopping.
            Disabled = 0,
            Enabled = 1
        ]
    ],

    pub UARTIMSC [
        RXIM OFFSET(4) NUMBITS(1) [
            Disabled = 0,
            Enabled = 1
        ]
    ],
    /// Interupt Clear Register
    pub UARTICR [
        /// Meta field for all pending interrupts
        ALL OFFSET(0) NUMBITS(11) [
            Clear = 0x7ff
        ]
    ]
];

register_structs! {
    pub PL011Regs {
        (0x00 => pub dr: ReadWrite<u32, UARTDR::Register>),                   // 0x00
        (0x04 => __reserved_0),               // 0x04
        (0x18 => pub fr: ReadOnly<u32, UARTFR::Register>),      // 0x18
        (0x1c => __reserved_1),               // 0x1c
        (0x24 => pub ibrd: WriteOnly<u32, UARTIBRD::Register>), // 0x24
        (0x28 => pub fbrd: WriteOnly<u32, UARTFBRD::Register>), // 0x28
        (0x2C => pub lcr_h: WriteOnly<u32, UARTLCR_H::Register>), // 0x2C
        (0x30 => pub cr: WriteOnly<u32, UARTCR::Register>),     // 0x30
        (0x34 => __reserved_2),               // 0x34
        (0x38 => pub imsc: ReadWrite<u32, UARTIMSC::Register>), // 0x38
        (0x44 => pub icr: WriteOnly<u32, UARTICR::Register>),   // 0x44
        (0x48 => @END),
    }
}
```

这一步我们使用**tock_registers**库完成

完成了内存地址映射之后，我们重新对之前构造的**Writer**进行修改，因为之前我们只用了pl011这个设备寄存器进行输出，而现在我们用到了整个UART进行数据收发

```rust
//嵌入式系统使用串口，而不是vga，直接输出，没有颜色控制，不记录列号，也没有frame buffer，所以采用空结构
pub struct Writer;

//往串口寄存器写入字节和字符串进行输出
impl Writer {
    pub fn write_byte(&mut self, byte: u8) {
        // ······
    }

    pub fn write_string(&mut self, s: &str) {
        // ······
    }

    pub fn new() -> Writer{
        unsafe {
            // pl011 device registers
            let pl011r: &PL011Regs = &*PL011REGS;
  
            // 禁用pl011
            pl011r.cr.write(UARTCR::TXE::Disabled + UARTCR::RXE::Disabled + UARTCR::UARTEN::Disabled);
            // 清空中断状态
            pl011r.icr.write(UARTICR::ALL::Clear);
            // 设定中断mask，需要使能的中断
            pl011r.imsc.write(UARTIMSC::RXIM::Enabled);
            // IBRD = UART_CLK / (16 * BAUD_RATE)
            // FBRD = ROUND((64 * MOD(UART_CLK,(16 * BAUD_RATE))) / (16 * BAUD_RATE))
            // UART_CLK = 24M
            // BAUD_RATE = 115200
            pl011r.ibrd.write(UARTIBRD::IBRD.val(13));
            pl011r.fbrd.write(UARTFBRD::FBRD.val(1));
            // 8N1 FIFO enable
            pl011r.lcr_h.write(UARTLCR_H::WLEN::EightBit + UARTLCR_H::PEN::Disabled + UARTLCR_H::STP2::Stop1
                + UARTLCR_H::FEN::Enabled);
            // enable pl011
            pl011r.cr.write(UARTCR::UARTEN::Enabled + UARTCR::RXE::Enabled + UARTCR::TXE::Enabled);
        }
  
        Writer
    }
}

impl core::fmt::Write for Writer {
// ······
```

为空结构体(标志)实现新的**方法**

方法中包含了打印和新建，重构**打印**函数

```
//嵌入式系统使用串口，而不是vga，直接输出，没有颜色控制，不记录列号，也没有frame buffer，所以采用空结构
pub struct Writer;

//往串口寄存器写入字节和字符串进行输出
impl Writer {
    pub fn write_byte(&mut self, byte: u8) {
        // const UART0: *mut u8 = 0x0900_0000 as *mut u8;
        unsafe {
            // pl011 device registers
            let pl011r: &PL011Regs = &*PL011REGS;
  
            // ptr::write_volatile(UART0, byte);
            pl011r.dr.write(UARTDR::DATA.val(byte as u32));
        }
    }

    pub fn write_string(&mut self, s: &str) {
    // ······
```

以上就是我们实现数据显现的过程也就是第二部分的内容，接下来处理数据接受的问题

一开始我们应该在**interrupts.rs**(中断合集)中对数据接受中断进行初始化描述，也就是**init_gicv2()**函数

```rust
// ······
    //配置timer
    unsafe {
        // ······
    }

    // 初始化UART0 中断
    // interrupts = <0x00 0x01 0x04>; SPI, 0x01, level
    set_config(UART0_IRQ, ICFGR_LEVEL); //电平触发
    set_priority(UART0_IRQ, 0); //优先级设定
    // set_core(TIMER_IRQ, 0x1); // 单核实现无需设置中断目标核
    clear(UART0_IRQ); //清除中断请求
    enable(UART0_IRQ); //使能中断

    loop {
        // ······
    }
// ······
```

```
新的代表数据接受中断的常量
// 时钟中断号
const TIMER_IRQ: u32 = 30;
// 设备中断号
const UART0_IRQ: u32 = 33;
```

在完成初始化之后，还要实现对应的函数

```rust
use tock_registers::interfaces::Readable;
fn handle_irq_lines(ctx: &mut ExceptionCtx, _core_num: u32, irq_num: u32) {
    if irq_num == TIMER_IRQ {
        handle_timer_irq(ctx);
    }else if irq_num == UART0_IRQ {
        handle_uart0_rx_irq(ctx);
    }
    else{
        catch(ctx, EL1_IRQ);
    }
}

fn handle_timer_irq(_ctx: &mut ExceptionCtx){

    crate::print!(".");

    // 每2秒产生一次中断
    unsafe {
        asm!("mrs x1, CNTFRQ_EL0");
        asm!("add x1, x1, x1");
        asm!("msr CNTP_TVAL_EL0, x1");
    }

}

fn handle_uart0_rx_irq(_ctx: &mut ExceptionCtx){
    use crate::uart_console::pl011::*;

    crate::print!("\nInput interrupt: ");
    unsafe{
        // pl011 device registers
        let pl011r: &PL011Regs = &*PL011REGS;

        let mut flag = pl011r.fr.read(UARTFR::RXFE);
        while flag != 1 {
            let value = pl011r.dr.read(UARTDR::DATA);

            crate::print!("{}", value as u8 as char);
            flag = pl011r.fr.read(UARTFR::RXFE);
        }
    }
}
```

这些函数将会在发生数据接收中断的时候被调用来处理相关的寄存器，接下来处理数据接收中断发生的时候被触发的函数

```rust
#[no_mangle]
unsafe extern "C" fn el1_irq(ctx: &mut ExceptionCtx) {
    // reads this register to obtain the interrupt ID of the signaled interrupt.
    // This read acts as an acknowledge for the interrupt.
    // 中断确认
    const GICC_IAR: *mut u32 = (GICC_BASE + 0x0c) as *mut u32;
    const GICC_EOIR: *mut u32 = (GICC_BASE + 0x10) as *mut u32;
    let value: u32 = ptr::read_volatile(GICC_IAR);
    let irq_num: u32 = value & 0x1ff;
    let core_num: u32 = value & 0xe00;

    // 实际处理中断
    handle_irq_lines(ctx, core_num, irq_num);
    // catch(ctx, EL1_IRQ);

    // A processor writes to this register to inform the CPU interface either:
    // • that it has completed the processing of the specified interrupt
    // • in a GICv2 implementation, when the appropriate GICC_CTLR.EOImode bit is set to 1, to indicate that the interface should perform priority drop for the specified interrupt.
    // 标记中断完成，清除相应中断位
    ptr::write_volatile(GICC_EOIR, core_num | irq_num);
    clear(irq_num);
}
```

`cargo build && qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/jiang_armv8_os`实现之后就可以了

# 关机重要的，呃至少能够重启

<br/>

---

要实现关机必然不可能脱离中断，因为外部IO想要交互最好的方法就是中断

经过查资料，gpio-keys中定义了一个poweroff键，也即gpio-keys是设备pl061的组成部分，现在要做的事情就比较明朗了，首先映射设备寄存器到内存

新定义一个模块pl061.rs

```rust
use tock_registers::{registers::{ReadWrite, WriteOnly}, register_bitfields, register_structs};

pub const PL061REGS: *mut PL061Regs = (0x0903_0000) as *mut PL061Regs;

register_bitfields![
    u32,
    pub GPIOIE [
        IO3 OFFSET(3) NUMBITS(1) [
            Disabled = 0,
            Enabled = 1
        ]
    ],
];

register_structs! {
    pub PL061Regs {
        (0x000 => __reserved_0),                                               // 0x000
        (0x410 => pub ie: ReadWrite<u32, GPIOIE::Register>),                   // 0x410
        (0x414 => __reserved_1),                                               // 0x414
        (0x41C => pub ic: WriteOnly<u32>),                                     // 0x41C
        (0x420 => @END),                                                       // 0x420
    }
}
```

在main.rs中引入定义的模块，接下来对新种类的中断在一开始的时候进行初始化(全局变量中断号，设备寄存器初始化)

```rust
const GPIO_IRQ: u32 = 39; // virt.dts interrupts = <0x00 0x07 0x04>; 32 + 0x07 = 39

pub fn init_gicv2() {
    // 初始化Gicv2的distributor和cpu interface
    // 禁用distributor和cpu interface后进行相应配置
    // ······

    // 初始化GPIO中断
    set_config(GPIO_IRQ, ICFGR_LEVEL); //电平触发
    set_priority(GPIO_IRQ, 0); //优先级设定
    // set_core(TIMER_IRQ, 0x1); // 单核实现无需设置中断目标核
    clear(GPIO_IRQ); //清除中断请求
    enable(GPIO_IRQ); //使能中断

    // 使能GPIO的poweroff key中断
    use crate::pl061::*;
    unsafe{
        let pl061r: &PL061Regs = &*PL061REGS;

        // 启用pl061 gpio中的3号线中断
        pl061r.ie.write(GPIOIE::IO3::Enabled);
    }

    loop {
        // ······
    }
}
// ······
```

记得还要导入新的设备寄存器内存地址映射

`use tock_registers::interfaces::Writeable;`

对中断控制器更新中断的种类

```rust
fn handle_irq_lines(ctx: &mut ExceptionCtx, _core_num: u32, irq_num: u32) {
    if irq_num == TIMER_IRQ {
        handle_timer_irq(ctx);
    }else if irq_num == UART0_IRQ {
        handle_uart0_rx_irq(ctx);
    }else if irq_num == GPIO_IRQ {
        handle_gpio_irq(ctx);
    }
    else{
        catch(ctx, EL1_IRQ);
    }
}
```

同时还有新的中断处理函数

```rust
fn handle_gpio_irq(_ctx: &mut ExceptionCtx){
    use crate::pl061::*;
    crate::println!("Power off!\n");
    unsafe {
        let pl061r: &PL061Regs = &*PL061REGS;

        // 清除中断信号
        pl061r.ic.set(pl061r.ie.get());
        // 关机
        asm!("mov w0, #0x18");
        asm!("hlt #0xF000");
    }
}
```

以上理论上来说就已经搞定了

为了启用Semihosting功能，在QEMU执行时需要加入 -semihosting 参数

`cargo build && qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/jiang_armv8_os -semihosting`

# 死锁

---

***我们总是把修漏洞放到重启功能确认无误之后，你知道吗？——阿姆斯特朗***

---

死锁不是一种操作系统的结构，是一种常规的bug,他主要表现为进程或线程之间互相竞争锁而导致卡死。

{% note info %}

什么是锁

锁这个概念是和并发一块出现的，如果A和B同时存储着C的内容进行修改，本来A应该把C改成D,然后B再把D改成E,如果发生了并发，也就是说B将获得C，然后不可避免导向一个完全错误的结果。

所以我们提出了锁和进程阻塞的概念，当A获得了C的锁，那么这个文件进程B就不能修改，而是睡觉等待A执行完成之后再唤醒B。

{% endnote %}

在我们写的系统中，现在可以看见的锁量只有一个，那就是我们为了实现打印实现的全局WRITE实例，谁获得这个实例谁就能打印字符，但是如果我们在打印的过程中发生中断而将CPU交给另外的打印进程，那么A进程由于失去了CPU而陷入沉睡保留锁，B进程获得了CPU但是没有锁就无法进行打印。

这个死锁成立的情况就是

- A睡着了，等B执行完之后才能唤醒
- B醒着但是没有锁，永远不会执行完，锁在睡着的A手中，A在等B。

## 复刻死锁

我们在主函数的空循环里面填入打印字符的要求，这会让她保持持有锁打印的状态

```rust
pub extern "C" fn not_main() {
    println!("\n[0] Hello from Rust!\n");
    interrupts::init_gicv2();
    loop {
        print!("-");
    }
}
```

我们之前为了验证时钟中断，在时钟中断处理函数中加入了打点输出的效果，我们把那个效果恢复一下。

```rust
fn handle_timer_irq(_ctx: &mut ExceptionCtx){

    crate::print!(".");

    //每两秒产生一次中断
    unsafe {
        asm!("mrs x1,CNTFRQ_EL0");
        asm!("add x1,x1,x1");
        asm!("msr CNTP_TVAL_EL0,x1");
    }

}
```

这样理论上就能触发死锁了。

## 解决

我们可以看到问题在于中断转移了CPU的所有权，从而发生死锁。由于我们只是搞一个简单的操作系统，所以我们用一种比较危险的方式来解决这个问题，那就是在输入的时候选择直接关闭中断。

编辑 `src/uart_console/mod.rs`，引入asm!宏

```rust
// ······
impl core::fmt::Write for Writer {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        // ······
    }
}

use core::{fmt, arch::asm};

use lazy_static::lazy_static;
use spin::Mutex;

use tock_registers::interfaces::Writeable;

pub mod pl011;
use pl011::*;
// ······
```

编辑src/uart_console/mod.rs中的_print()函数，在处理输入时先关闭中断，再打开。

```rust
// ······
/// Prints the given formatted string to the VGA text buffer through the global `WRITER` instance.
#[doc(hidden)]
pub fn _print(args: fmt::Arguments) {
    use core::fmt::Write;
    unsafe {
        // 关闭d a i f类型的中断
        asm!("msr daifset, #0xf");
    }

    WRITER.lock().write_fmt(args).unwrap();

    unsafe {
        // 仅打开i类型的中断，不支持嵌套，嵌套应该保存状态，然后再恢复之前的状态
        asm!("msr daifclr, #2");
    }
}
```

此时我们会发现死锁现象消失。

# 结束

上半部分到此结束，下半部分有时间更新。
