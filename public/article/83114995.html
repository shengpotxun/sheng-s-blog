<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《操作系统实验的部分实现》实验日志(上) | Sheng's blog</title><meta name="keywords" content="操作系统"><meta name="author" content="Sheng xun"><meta name="copyright" content="Sheng xun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f1e2c1"><meta name="description" content="这是一个实验的记录，原理性的内容没有非常严谨。 参考资料  Writing an OS in Rust BlogOS：ARM v8之旅 语言：Rust 环境：ubuntu20.04  安装环境 123456789curl --proto &amp;#x27;&#x3D;https&amp;#x27; --tlsv1.2 -sSf https:&#x2F;&#x2F;sh.rustup.rs | sh&#x2F;&#x2F;安装rustsource $HOME&#x2F;.">
<meta property="og:type" content="article">
<meta property="og:title" content="《操作系统实验的部分实现》实验日志(上)">
<meta property="og:url" content="http://shengxun.xyz/article/83114995.html">
<meta property="og:site_name" content="Sheng&#39;s blog">
<meta property="og:description" content="这是一个实验的记录，原理性的内容没有非常严谨。 参考资料  Writing an OS in Rust BlogOS：ARM v8之旅 语言：Rust 环境：ubuntu20.04  安装环境 123456789curl --proto &amp;#x27;&#x3D;https&amp;#x27; --tlsv1.2 -sSf https:&#x2F;&#x2F;sh.rustup.rs | sh&#x2F;&#x2F;安装rustsource $HOME&#x2F;.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/008tudqVgy1h554mk0s86j315o0ngqmf.jpg">
<meta property="article:published_time" content="2022-08-13T06:19:54.000Z">
<meta property="article:modified_time" content="2022-08-27T14:55:25.684Z">
<meta property="article:author" content="Sheng xun">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tva1.sinaimg.cn/large/008tudqVgy1h554mk0s86j315o0ngqmf.jpg"><link rel="shortcut icon" href="/img/letter-s.png"><link rel="canonical" href="http://shengxun.xyz/article/83114995"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《操作系统实验的部分实现》实验日志(上)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-27 22:55:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#3b221a')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f1e2c1')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/change.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/headline.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa fa-comment-dots"></i><span> Moments</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-image"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-clipboard-list"></i><span> Messageboard</span></a></div><div class="menus_item"><a class="site-page" href="/diary/"><i class="fa-fw fa fa-book"></i><span> Diary</span></a></div><div class="menus_item"><a class="site-page" href="/buycoffee/"><i class="fa-fw fa fa-mug-hot"></i><span> Buy me a coffee</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://tva1.sinaimg.cn/large/008tudqVgy1h554mk0s86j315o0ngqmf.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Sheng's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa fa-comment-dots"></i><span> Moments</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-image"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-clipboard-list"></i><span> Messageboard</span></a></div><div class="menus_item"><a class="site-page" href="/diary/"><i class="fa-fw fa fa-book"></i><span> Diary</span></a></div><div class="menus_item"><a class="site-page" href="/buycoffee/"><i class="fa-fw fa fa-mug-hot"></i><span> Buy me a coffee</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《操作系统实验的部分实现》实验日志(上)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-13T06:19:54.000Z" title="发表于 2022-08-13 14:19:54">2022-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-27T14:55:25.684Z" title="更新于 2022-08-27 22:55:25">2022-08-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%9E%E9%AA%8C%E6%97%A5%E5%BF%97/">实验日志</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《操作系统实验的部分实现》实验日志(上)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>这是一个实验的记录，原理性的内容没有非常严谨。</p>
<p>参考资料</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://os.phil-opp.com/vga-text-mode/">Writing an OS in Rust</a></li>
<li><a target="_blank" rel="noopener" href="https://acmezone.top/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/">BlogOS：ARM v8之旅</a><br>
语言：Rust<br>
环境：ubuntu20.04</li>
</ul>
<h1>安装环境</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh//安装rust</span><br><span class="line">source $HOME/.cargo/env//激活rust</span><br><span class="line">rustup default nightly//将rust版本调整为nightly</span><br><span class="line">sudo apt install gcc//安装gcc编译器为编译提供支持</span><br><span class="line">cargo install cargo-binutils rustfilt//安装相关的rust工具</span><br><span class="line">rustup target add aarch64-unknown-none-softfloat//由于我们是arm v8架构，所以要提供arm v8支持</span><br><span class="line">sudo apt-get install qemu qemu-system-arm//安装qemu模拟器方便我们检验自己写的操作系统</span><br><span class="line">sudo apt-get install libncursesw5 libpython2.7 axel//安装python的相关库</span><br><span class="line">axel -n 32 -a https://developer.arm.com/-/media/Files/downloads/gnu-a/10.3-2021.07/binrel/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf.tar.xz</span><br></pre></td></tr></table></figure>
<h1>裸机</h1>
<p>为了创建裸机程序，首先我们要用cargo新建一个项目<br>
<code>cargo new jiang_os</code></p>
<p>新建完成</p>
<p>一个裸机应该是独立于现有的操作系统的，也就是不使用所有的rust标准库以及本机的接口，所以首先就要断掉所有的标准库，在main中加入<br>
<code>#![no_std]</code><br>
在弃用了标准库以后，也就不能使用println这样的宏了，所以删掉</p>
<p>然后就是panic报错函数，正常情况下，发生panic的时候会调用panic函数，然而现在的panic已经被我们禁用了，所以我们要自己写一个，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#panic</span><br><span class="line"><span class="comment">//要使用rust core库里面的panic里面的panicinfo，这玩意是没有返回值的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> :: painc::Panicinfo<span class="comment">//我要用core里面的panic里面的panicinfo，这个东西用来重写一下panic</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info &amp;panicinfo)<span class="punctuation">-&gt;</span> !&#123;</span><br><span class="line">    <span class="keyword">loop</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们禁用了panic,紧跟着用于发生panic时结束错误并释放内存的语言项eh_personality也给我报错所以又要重写一个释放内存的内容，但是这技术要求比较高，我们直接让panic发生的时候把任务终止就行了，不那么麻烦</p>
<p>在我们运行程序之前，会有一个准备工作的过程，这个过程会构建C语言程序的环境并且接上函数的入口点，现在我们已经禁止了所有的标准库，这个过程我们也要手动实现才行，所以我们首先是把预订的入口点main给禁用了加入 <code>#![no_main]</code></p>
<p>入口点怎么写：</p>
<ul>
<li>首先它应该被[no_mangle]标记，以便编译器在编译过后不会随便起一个名字，导致我们没有办法识别到_start</li>
<li>然后它应该没有返回值，因为它不会被调用，除非是系统本身</li>
<li>我先写个无限循环充数</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[no_mange]</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span> () <span class="punctuation">-&gt;</span> !&#123;</span><br><span class="line">    <span class="keyword">loop</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>我们先前已经把所有的内容都脱离了本机系统，但是链接器在链接的时候会默认使用的C语言环境所以不行，我们要设定链接器脱离C环境，而且还得是arrch为目标平台。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//_start.s的代码</span><br><span class="line">.globl _start</span><br><span class="line">.extern LD_STACK_PTR</span><br><span class="line">.section &quot;.text.boot&quot;</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">        ldr     x30, =LD_STACK_PTR</span><br><span class="line">        mov     sp, x30</span><br><span class="line">        bl      not_main</span><br><span class="line"></span><br><span class="line">.equ PSCI_SYSTEM_OFF, 0x84000002</span><br><span class="line">.globl system_off</span><br><span class="line">system_off:</span><br><span class="line">        ldr     x0, =PSCI_SYSTEM_OFF</span><br><span class="line">        hvc     #0</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//arrch64链接器脚本</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = 0x40080000;</span><br><span class="line">    .text.boot : &#123; *(.text.boot) &#125;</span><br><span class="line">    .text : &#123; *(.text) &#125;</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    .bss : &#123; *(.bss) &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(8);</span><br><span class="line">    . = . + 0x4000;</span><br><span class="line">    LD_STACK_PTR = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;abi-blacklist&quot;: [</span><br><span class="line">      &quot;stdcall&quot;,</span><br><span class="line">      &quot;fastcall&quot;,</span><br><span class="line">      &quot;vectorcall&quot;,</span><br><span class="line">      &quot;thiscall&quot;,</span><br><span class="line">      &quot;win64&quot;,</span><br><span class="line">      &quot;sysv64&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;arch&quot;: &quot;aarch64&quot;,</span><br><span class="line">    &quot;data-layout&quot;: &quot;e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128&quot;,</span><br><span class="line">    &quot;disable-redzone&quot;: true,</span><br><span class="line">    &quot;env&quot;: &quot;&quot;,</span><br><span class="line">    &quot;executables&quot;: true,</span><br><span class="line">    &quot;features&quot;: &quot;+strict-align,+neon,+fp-armv8&quot;,</span><br><span class="line">    &quot;is-builtin&quot;: false,</span><br><span class="line">    &quot;linker&quot;: &quot;rust-lld&quot;,</span><br><span class="line">    &quot;linker-flavor&quot;: &quot;ld.lld&quot;,</span><br><span class="line">    &quot;linker-is-gnu&quot;: true,</span><br><span class="line">    &quot;pre-link-args&quot;: &#123;</span><br><span class="line">      &quot;ld.lld&quot;: [&quot;-Taarch64-qemu.ld&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;llvm-target&quot;: &quot;aarch64-unknown-none&quot;,</span><br><span class="line">    &quot;max-atomic-width&quot;: 128,</span><br><span class="line">    &quot;os&quot;: &quot;none&quot;,</span><br><span class="line">    &quot;panic-strategy&quot;: &quot;abort&quot;,</span><br><span class="line">    &quot;relocation-model&quot;: &quot;static&quot;,</span><br><span class="line">    &quot;target-c-int-width&quot;: &quot;32&quot;,</span><br><span class="line">    &quot;target-endian&quot;: &quot;little&quot;,</span><br><span class="line">    &quot;target-pointer-width&quot;: &quot;64&quot;,</span><br><span class="line">    &quot;vendor&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是core的问题，平时我们的core是环境提供好的，由于[no_std]之后脱离了主机环境，所以我们必须自己core编译一遍，我查了一下，有两种办法，要么你用xbuild，xbuild自带core的，要么你自己修改一下core的配置</p>
<p>新建一个文件夹.cargo/，然后放config文件</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//config</span></span><br><span class="line">[unstable]</span><br><span class="line">build-std=[<span class="string">&quot;core&quot;</span>,<span class="string">&quot;compiler_builtins&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>接下来是实现引导程序，这个比较复杂，抄的的start.s</p>
<p>现在一个完整的裸机已经构建成功了，虽然运行它还是什么都没有，所以接下来给它实现一点功能，比如把调用VGA字符缓冲区的环节，包装成一个printf宏然后输出我最喜欢的 “hello world”</p>
<hr>
<p><em><strong>没有一个程序员不喜欢hello world，就好像没有人能拒绝芹菜猪肉饺子——鲁迅</strong></em></p>
<hr>
<h2 id="hello-world">hello world</h2>
<div class="note primary flat"><h4 id="无效内容，解释了一点VGA原理">无效内容，解释了一点VGA原理</h4>
<p>我们使用VGA，本来可以用RUST模块的，但是我们用不到别的东西，这样就很多余，就直接建一个文件就好</p>
<p>在前面的构建中，我们已经初步接触到了VGA字符缓冲区，这个字符缓冲区是由二位数组，这个二维数组的每一个16位数字（一般情况下）都会按照格式直接输出到屏幕，下面是一般情况下数字的含义的解读方式</p>
<table>
<thead>
<tr>
<th>数0～7位字</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0～7位</td>
<td>ascll码</td>
</tr>
<tr>
<td>8～11</td>
<td>前景色</td>
</tr>
<tr>
<td>12～14</td>
<td>背景色</td>
</tr>
<tr>
<td>15</td>
<td>加亮</td>
</tr>
</tbody>
</table>
<p>很明显16位8字节那么我们就要构建一个随时随地都能调用这个VGA字符缓冲区的东西，把他封装起来</p>
<p>到这里，就发现一个问题，什么是缓冲区，怎么读取这个缓冲区，下面解释什么叫做缓冲区</p>
<p><strong>缓冲区</strong>：就是缓存，缓存是干什么用的，缓存是用来存储即将输出的内容，和即将输入的内容的，为什么要有这么个东西呢，计算机从读写磁盘是非常慢的如果每次都从磁盘开始，效率就比较低，从缓存就快多了，或者我们可以先把内容送到缓存里面，然后直接机械处理就行了，不需要再占用CPU，就快了</p>
<p>那我们这里的字符缓冲区，很明显是一个控制输出的缓存地带，也就是我们把里面的内容改成什么就会机械输出什么内容。那我们怎么访问这个缓存呢，缓存也是内存的一部分，直接访问内存就行了。</p>
<br/>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/vga_buffer.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(dead_code)]</span></span><br><span class="line"><span class="meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span><br><span class="line"><span class="meta">#[repr(u8)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Black = <span class="number">0</span>,</span><br><span class="line">    Blue = <span class="number">1</span>,</span><br><span class="line">    Green = <span class="number">2</span>,</span><br><span class="line">    Cyan = <span class="number">3</span>,</span><br><span class="line">    Red = <span class="number">4</span>,</span><br><span class="line">    Magenta = <span class="number">5</span>,</span><br><span class="line">    Brown = <span class="number">6</span>,</span><br><span class="line">    LightGray = <span class="number">7</span>,</span><br><span class="line">    DarkGray = <span class="number">8</span>,</span><br><span class="line">    LightBlue = <span class="number">9</span>,</span><br><span class="line">    LightGreen = <span class="number">10</span>,</span><br><span class="line">    LightCyan = <span class="number">11</span>,</span><br><span class="line">    LightRed = <span class="number">12</span>,</span><br><span class="line">    Pink = <span class="number">13</span>,</span><br><span class="line">    Yellow = <span class="number">14</span>,</span><br><span class="line">    White = <span class="number">15</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释上面三行的内容，首先就是我们新建了一个Color，rust是一个比较严谨的语言如果你新建变量而不使用这个变量，它会报错，所以这里要让它不报错，就加入一个 <code>allow(dead_code)</code>这样就可以不报错了。</p>
<p>Rust语言中的trait是非常重要的概念。在中文里，trait可以翻译为“特征”、“特点”、“特性”等。在Rust中，trait这一个概念承担了多种职责。Rust编程语言内置的derive属性可以快速地替我们的类型加上内置的特性，不过会要求该类型内的字段也都要先实作相同的特性，而且很多时候利用derive属性实作出来的特性并不能达到我们期望的功能。加上这些特性trait之后，它会遵循复制语义，rust在内存管理方面非常严格，对于rust来说有必要对移动语义和复制语义进行区分。</p>
<blockquote>
<p>语法和文法结构有关，然而语义和按照这个结构所组合的单词符号的意义有关。合理的语法结构并不表明语义是合法的。例如我们常说：我上大学，这个句子是符合语法规则的，也符合语义规则。但是大学上我，虽然符合语法规则，但没有什么意义，所以说是不符合语义的。</p>
</blockquote>
<p>repr指定数据类型，这里就是8位二进制数字，其实颜色四个二进制数字就可以全部表示完(16个颜色)，但是rust不支持4位二进制，它最小一字节</p>
<p>rust里面有一个像是穷举的东西叫做enum，这是个<strong>枚举类</strong>，我们用这个东西让颜色和数字对应，这样目的是为了让字符缓冲区认识你在干嘛</p>
<p>用穷举法，直接让所有的颜色对应一个数字</p>
<p>有了颜色，上面表（开头VGA的表）里的前景色和背景色不就肯定能够实现了吗，由于四位表示前景色，四位表示背景色，我们构造统一的一个8位数据类型，这个数据类型四位前景色，后四位背景色，专门用来表示颜色属性</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span><br><span class="line"><span class="meta">#[repr(transparent)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ColorCode</span>(<span class="type">u8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ColorCode</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(foreground: Color, background: Color) <span class="punctuation">-&gt;</span> ColorCode &#123;</span><br><span class="line">        <span class="title function_ invoke__">ColorCode</span>((background <span class="keyword">as</span> <span class="type">u8</span>) &lt;&lt; <span class="number">4</span> | (foreground <span class="keyword">as</span> <span class="type">u8</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之前一直都设定的都是u8，地址都是8的倍数，我们要保持一致，所以我们就用 <code>repr(transparent)</code>来保证我们送进去的是u8,传出来的还是u8</p>
<hr>
<p>Q:保持对齐有什么作用</p>
<p>A:编译原理，内存访问的时候是通过寄存器的整数倍加减控制的</p>
<hr>
<p>颜色搞定，然后还有很多内容，然后我们全部塞进一个大的结构体里面用来详细描述字符缓冲区和字符</p>
<p>在rust里面定义的结构体不会按照顺序在内存里面排列，这就很麻烦，我们直接为我们自己设置的结构体制定内存顺序是“C语言”顺序，这样它就不会乱了，这个结构体里面的内容是前面8位是ascll码，后面8位颜色</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ScreenChar</span> &#123;</span><br><span class="line">    ascii_character: <span class="type">u8</span>,</span><br><span class="line">    color_code: ColorCode,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BUFFER_HEIGHT: <span class="type">usize</span> = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">const</span> BUFFER_WIDTH: <span class="type">usize</span> = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(transparent)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在我们有16位也就是两个字节，一个内存就是两个字节，刚刚好不多不少，那么我们现在就要设置字符缓冲区的范围了，这个buffer（缓存）我们设置一个25×80的字符数组，一个字符类型也是16位一个字节，全部都是刚好的</p>
<p>然后还有一个老问题，也就是这个buffer在内存中的对齐问题，我们应该还是u8才对，所以我们设置 <code>repr(transparent)</code>上下统一，相较于一般的字符缓冲区，我们的这个它没有bling加亮，对于我们输出一个hello world或者一个五彩斑斓的hello world，这个缓冲区的字符类型应该是够用了，如果你需要一个闪闪发亮的hello world那就不行了</p>
<br/>
<blockquote>
<p>至此我们构建字符缓冲区已经完毕</p>
</blockquote>
<p>接下来我们就得让这个字符缓冲区发挥作用了，越来越靠近我们熟悉的阶段了</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">    column_position: <span class="type">usize</span>,</span><br><span class="line">    color_code: ColorCode,</span><br><span class="line">    buffer: &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Buffer,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>搞一个write类型，这个类型得调用之前写出来的缓冲区，把字符写到最后一行，并且在遇到换行符的时候所有字符向上移动一行，然后这串字符可能会有背景颜色和前景色</p>
<p>column_position 变量将跟踪光标在最后一行的位置，然后颜色由color_code来指定，然后又转到我们写的ColorCode上面，这样就决定了前景色和背景色，然后告诉编译器我的缓存buffer是我自己写出来的Buffer，然后因为Rust的特性，我们只能借用这个Buffer，为了确保这个借用是一直都可以用的我们给这个借用加上一个static生命周期，这说明这个借用会在整个程序的运行期间有效</p>
<blockquote>
<p>那我们要打印字符就要一个打印的方法，写一个为write类型实现的方法</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write_byte</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, byte: <span class="type">u8</span>) &#123;</span><br><span class="line">        <span class="keyword">match</span> byte &#123;</span><br><span class="line">            <span class="string">b&#x27;\n&#x27;</span> =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">new_line</span>(),</span><br><span class="line">            byte =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.column_position &gt;= BUFFER_WIDTH &#123;</span><br><span class="line">                    <span class="keyword">self</span>.<span class="title function_ invoke__">new_line</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">row</span> = BUFFER_HEIGHT - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">col</span> = <span class="keyword">self</span>.column_position;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">color_code</span> = <span class="keyword">self</span>.color_code;</span><br><span class="line">                <span class="keyword">self</span>.buffer.chars[row][col].<span class="title function_ invoke__">write</span>(ScreenChar &#123;</span><br><span class="line">                    ascii_character: byte,</span><br><span class="line">                    color_code: color_code,</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">self</span>.column_position += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new_line</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> <span class="number">1</span>..BUFFER_HEIGHT &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">col</span> <span class="keyword">in</span> <span class="number">0</span>..BUFFER_WIDTH &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">character</span> = <span class="keyword">self</span>.buffer.chars[row][col].<span class="title function_ invoke__">read</span>();</span><br><span class="line">                <span class="keyword">self</span>.buffer.chars[row - <span class="number">1</span>][col].<span class="title function_ invoke__">write</span>(character);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">clear_row</span>(BUFFER_HEIGHT - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">self</span>.column_position = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法里面要有两个部分，一个是打印字符的部分，另一个是换行的部分，先往里面写两个方法签名<strong>write_byte</strong>和<strong>new_line</strong>，依次来看</p>
<ul>
<li><strong>write_byte</strong></li>
</ul>
<p>如果我们输入的是一个换行符，那我们应该什么都不要打印，直接开一个新行，也就是直接调用new_line就行了，然后如果这时候光标位置（colum_position）已经超过了一整行，那同样也要换行调用new_line，除此以外我们每次写入最后一行的光标指向的缓冲区，ascll码字节ScreenChar，然后把光标向后移动一个位置</p>
<ul>
<li><strong>new_line</strong></li>
</ul>
<p>这个部分也比较简单，我们直接遍历所有字符然后向上移动一位，很好理解，换行本来是输入向下一行，相对来说就是所有内容向上一行，然而要注意的是我们应该从第1行开始，因为第0行会直接被原第一行覆盖，光标现在所处的这一行应该被清空，清空可以额外写一个方法<strong>clear_row</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">clear_row</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, row: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">blank</span> = ScreenChar &#123;</span><br><span class="line">            ascii_character: <span class="string">b&#x27; &#x27;</span>,</span><br><span class="line">            color_code: <span class="keyword">self</span>.color_code,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">col</span> <span class="keyword">in</span> <span class="number">0</span>..BUFFER_WIDTH &#123;</span><br><span class="line">            <span class="keyword">self</span>.buffer.chars[row][col].<span class="title function_ invoke__">write</span>(blank);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后为了实现字符串输出，我们还是得把多个write_byte整合到一个write_string中</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write_string</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">byte</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> byte &#123;</span><br><span class="line">                <span class="comment">// 可以是能打印的 ASCII 码字节，也可以是换行符</span></span><br><span class="line">                <span class="number">0x20</span>..=<span class="number">0x7e</span> | <span class="string">b&#x27;\n&#x27;</span> =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">write_byte</span>(byte),</span><br><span class="line">                <span class="comment">// 不包含在上述范围之内的字节</span></span><br><span class="line">                _ =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">write_byte</span>(<span class="number">0xfe</span>),</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>但是我想用格式化宏，因为格式化宏可以不需要每次都实例化</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Write <span class="keyword">for</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">byte</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> byte &#123;</span><br><span class="line">                <span class="comment">// 可以是能打印的 ASCII 码字节，也可以是换行符</span></span><br><span class="line">                <span class="number">0x20</span>..=<span class="number">0x7e</span> | <span class="string">b&#x27;\n&#x27;</span> =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">write_byte</span>(byte),</span><br><span class="line">                <span class="comment">// 不包含在上述范围之内的字节</span></span><br><span class="line">                _ =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">write_byte</span>(<span class="number">0xfe</span>),</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里补充说明一下，为了不让编译器把我们的读写操作优化掉，我们要改变一下screenchar的数据类型，因为编译器不知道我们在操作的是VGA还是是普通的内存RAM，把ScreenChar改成一个Volatile类型，这个类型的读写只能通过自带的write和read</p>
<p>写到这出问题了，<strong>张</strong>和<strong>万</strong>提醒我目标系统是个virt</p>
<p><img src="http://tva1.sinaimg.cn/large/008tudqVgy1h5550l86y9j303200jq2r.jpg" alt="a315b81d287d5b3b1baa3812c77e180f.png"><br>
virt机器有个pl011设备，这个设备的寄存器在0x9000000开始，virt用pl011作为标准输出，这是因为与PC不同，大部分嵌入式系统默认情况下并不包含VGA设备。没有VGA我直接白写。</p>
<p>我，我全白写啊啊啊啊啊啊啊啊啊</p>
</div>
<p><em><strong>打代码睡大觉，审题眼睛睁不开，看见成绩被吓到，求老师一面网开——汤家凤</strong></em></p>
<hr>
<p>virt机器有个pl011设备，这个设备的寄存器在0x9000000开始，virt用pl011作为标准输出，这是因为与PC不同，大部分嵌入式系统默认情况下并不包含VGA设备。没有VGA我直接白写。</p>
<p>串口相较于VGA更加简单一点</p>
<p>先把模块改个名字 <code>uart_console.rs</code></p>
<p>对于串口来说，没有颜色没有缓存，所以Writer结构体没有元素是一个空结构体，更多的起到一个标志的作用，用来标记Write的方法</p>
<p>实现方法的过程也更加简单一点，已知了pl011的寄存器在virt机器中被映射到了0x9000000的内存位置，直接写一个静态指针，然后修改内存的值，由于串口的性质，读写操作比较特殊，比如我可能值已经送走了，此时要求再次读一下串口，值应该是变化的，但是编译器可能优化成相同的值从寄存器里复制一下，所以做一个易失操作，告诉编译器不要优化。打印字符串就更加简单了反复调用打印字节就行</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//往串口寄存器写入字节和字符串进行输出</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write_byte</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, byte: <span class="type">u8</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> UART0: *<span class="keyword">mut</span> <span class="type">u8</span> = <span class="number">0x0900_0000</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            ptr::<span class="title function_ invoke__">write_volatile</span>(UART0, byte);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write_string</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">byte</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">write_byte</span>(byte <span class="keyword">as</span> <span class="type">u8</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后使用RUST自带的格式化宏，给Write带上一个trait，trait是共享方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">core</span>::fmt::Write <span class="keyword">for</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">write_string</span>(s);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，Ok(()) 属于 Result 枚举类型中的 Ok，包含一个值为 () 的变量。</p>
<p>写到这里已经可以正常输出字符了，但是我每次都必须构建一个Writer的实例，这就很麻烦。我要一个全局接口，为了获得一个全局接口我还要做一些工作</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> WRITER: Writer = Writer &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>然后我就想了一下，Rust对于静态变量初始化有特殊的要求，一般的我们直接在编译的时候就初始化了，在Rust里面是编译器的常量求值器搞定的，但是这个常量求值器有的时候搞不定就要延迟初始化，但是这里的Write里面是空的肯定是不需要的。</p>
<p>然后我们就要调用这个实例，但是一个静态的实例比较难搞，要么直接可变静态，但是这个会导致数据冲突，同时有一个以上的东西在修改数据，就肯定不行，于是我们就可以找一些本身提供可变的类型。要定义同步的内部可变性，我们往往使用标准库提供的互斥锁类 Mutex</p>
<blockquote>
<p>互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。</p>
<p>注意: 互斥锁是多个线程一起去抢，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。</p>
</blockquote>
<p>但是我们这里是没有阻塞的，因为我们写的简单操作系统还没有这个东西，还有一种较为基础的互斥锁实现方式——自旋锁（spinlock）。自旋锁并不会调用阻塞逻辑，而是在一个小的无限循环中反复尝试获得这个锁，也因此会一直占用 CPU 时间，直到互斥锁被它的占用者释放。</p>
<p>为了使用自旋的互斥锁，我们添加 spin包 到项目的依赖项列表：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">in</span> Cargo.toml</span><br><span class="line">[dependencies]</span><br><span class="line">spin = <span class="string">&quot;0.9.2&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> WRITER: Mutex&lt;Writer&gt; = Mutex::<span class="title function_ invoke__">new</span>(Writer&#123;&#125;）</span><br></pre></td></tr></table></figure>
<p>有了全局的实例，就能实现全局的宏</p>
<p>标准库里面的println!和print!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    () =&gt; (<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    ($($arg:tt)*) =&gt; (<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;\n&quot;</span>, <span class="built_in">format_args!</span>($($arg)*)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($($arg:tt)*) =&gt; ($crate::io::_print(<span class="built_in">format_args!</span>($($arg)*)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>println!有两个规则，一个是没有参数输入的时候就换行，另一个是打印字符串会直接调用print!，然后补上一个换行。</p>
<p>print!这个宏将扩展为一个对 io 模块中 _print 函数的调用，然后我们稍微改一下，指向我们自己写的模块，里面的_print函数</p>
<br/>
<p>#[macro_export] 属性让整个包（crate）和基于它的包都能访问这个宏，而不仅限于定义它的模块（module）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Like the `print!` macro in the standard library, but prints to the VGA text buffer.</span></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($($arg:tt)*) =&gt; ($crate::uart_console::_print(<span class="built_in">format_args!</span>($($arg)*)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Like the `println!` macro in the standard library, but prints to the VGA text buffer.</span></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    () =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    ($($arg:tt)*) =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;\n&quot;</span>, <span class="built_in">format_args!</span>($($arg)*)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">_print</span>(args: fmt::Arguments) &#123;</span><br><span class="line">    <span class="keyword">use</span> core::fmt::Write;</span><br><span class="line"></span><br><span class="line">    WRITER.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">write_fmt</span>(args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在已经可以直接使用</p>
<h1>从放弃轮询到写不出中断</h1>
<hr>
<p><em><strong>人类获得了火焰从猿走向人，底层程序猿获得了中断走向猴子都不如——阿基米德</strong></em></p>
<hr>
<p>现代操作系统是基于中断的，写到这里我们也到了向这个简单操作系统中加入中断的时候了，在写之我们得查看设备手册获得必要的知识</p>
<h2 id="基础知识">基础知识</h2>
<p>首先我们用的是armv8架构中断控制器是GICv2</p>
<p>GIC对一个中断源的处理过程包含Inactive, Pending, Active和Active and Pending四种状态。</p>
<ul>
<li><strong>Inactive</strong>:没有触发</li>
<li><strong>Pending</strong>：待处理，IAR寄存器标志为1</li>
<li><strong>Active</strong>：读取IAR，并且将IAR清零，处理器回复ACK信号给GIC</li>
<li><strong>Active and pending</strong>：第二个中断来了，前一个还在处理</li>
</ul>
<p>GIC中断控制器定义了3种中断</p>
<ul>
<li>SGI（Software Generated Interrupt）
<ul>
<li>中断号是0-15之间</li>
<li>用于core之间相互通信，由软件触发的中断，也可以称为IPI中断</li>
</ul>
</li>
<li>PPI（Private Perpheral Interrupt）
<ul>
<li>中断号在16-31之间</li>
<li>此类中断是每个core私有的，只用于当前core处理一些业务时使用，比如每个core上有一个tick中断，用于进程调度使用</li>
</ul>
</li>
<li>SPI（Shared Perpheral Interrupt）
<ul>
<li>中断号在32-1020之间</li>
<li>此类中断是由外设触发的中断信号产线，比如touch的触摸屏中断等</li>
</ul>
</li>
</ul>
<h3 id="Distributor仲裁器">Distributor仲裁器</h3>
<p>所有GICD开头的都是 distributor的寄存器，用来实现不同的功能</p>
<p>仲裁器的主要作用是对中断优先级排序，以及将SPI和PPI中断分发到Redistributor和CPU-Interface模块，仲裁器对应的寄存器为GICD_CTLR</p>
<ul>
<li>GICD_ISENABLER:中断使能，1bit关联一个中断</li>
<li>GICD_ICENABLER：中断禁止，1bit关联一个中断</li>
<li>GICD_ICPENDR：修改中断pending状态，1bit关联一个中断</li>
<li>GICD_IPRIORITYR：设置中断优先级，字节有效一个字节对应一个中断</li>
<li>GICD_ICFGR：设置中断触发类型</li>
</ul>
<h3 id="CPU-interfacce">CPU interfacce</h3>
<p>然后CPU interface是用来判断优先级并决定是否向CPU传递</p>
<p>GICC_CTLR是开头也是一个标志位</p>
<p>功能</p>
<ul>
<li>GICC_PMR：进行优先级判定，只有优先级比这个寄存器里面的值大才能向CPU传递</li>
<li>GICC_BPR：对优先级规则的细化</li>
</ul>
<p>获得以上知识之后我们就可以开始写了</p>
<h2 id="过程">过程</h2>
<p>首先是新建一个模块</p>
<p><code>interrupts.rs</code></p>
<p>然后向里面写入各个寄存器的内存地址映像以及必要的常量数据</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GICD和GICC寄存器内存映射后的起始地址</span></span><br><span class="line"><span class="keyword">const</span> GICD_BASE: <span class="type">u64</span> = <span class="number">0x08000000</span>;</span><br><span class="line"><span class="keyword">const</span> GICC_BASE: <span class="type">u64</span> = <span class="number">0x08010000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Distributor</span></span><br><span class="line"><span class="keyword">const</span> GICD_CTLR: *<span class="keyword">mut</span> <span class="type">u32</span> = (GICD_BASE + <span class="number">0x0</span>) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u32</span>;<span class="comment">//仲裁器</span></span><br><span class="line"><span class="keyword">const</span> GICD_ISENABLER: *<span class="keyword">mut</span> <span class="type">u32</span> = (GICD_BASE + <span class="number">0x0100</span>) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u32</span>;<span class="comment">//中断使能，1bit关联一个中断</span></span><br><span class="line"><span class="keyword">const</span> GICD_ICENABLER: *<span class="keyword">mut</span> <span class="type">u32</span> = (GICD_BASE + <span class="number">0x0180</span>) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u32</span>;<span class="comment">//中断禁止，1bit关联一个中断</span></span><br><span class="line"><span class="keyword">const</span> GICD_ICPENDR: *<span class="keyword">mut</span> <span class="type">u32</span> = (GICD_BASE + <span class="number">0x0280</span>) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u32</span>;<span class="comment">//修改中断pending状态，1bit关联一个中断</span></span><br><span class="line"><span class="keyword">const</span> GICD_IPRIORITYR: *<span class="keyword">mut</span> <span class="type">u32</span> = (GICD_BASE + <span class="number">0x0400</span>) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u32</span>;<span class="comment">//设置中断优先级，字节有效一个字节对应一个中断</span></span><br><span class="line"><span class="keyword">const</span> GICD_ICFGR: *<span class="keyword">mut</span> <span class="type">u32</span> = (GICD_BASE + <span class="number">0x0c00</span>) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u32</span>;<span class="comment">//设置中断触发类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> GICD_CTLR_ENABLE: <span class="type">u32</span> = <span class="number">1</span>;  <span class="comment">/* Enable GICD */</span></span><br><span class="line"><span class="keyword">const</span> GICD_CTLR_DISABLE: <span class="type">u32</span> = <span class="number">0</span>;     <span class="comment">/* Disable GICD */</span></span><br><span class="line"><span class="keyword">const</span> GICD_ISENABLER_SIZE: <span class="type">u32</span> = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">const</span> GICD_ICENABLER_SIZE: <span class="type">u32</span> = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">const</span> GICD_ICPENDR_SIZE: <span class="type">u32</span> = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">const</span> GICD_IPRIORITY_SIZE: <span class="type">u32</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> GICD_IPRIORITY_BITS: <span class="type">u32</span> = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> GICD_ICFGR_SIZE: <span class="type">u32</span> = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">const</span> GICD_ICFGR_BITS: <span class="type">u32</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CPU Interface</span></span><br><span class="line"><span class="keyword">const</span> GICC_CTLR: *<span class="keyword">mut</span> <span class="type">u32</span> = (GICC_BASE + <span class="number">0x0</span>) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u32</span>;<span class="comment">//cpu interface的寄存器起始</span></span><br><span class="line"><span class="keyword">const</span> GICC_PMR: *<span class="keyword">mut</span> <span class="type">u32</span> = (GICC_BASE + <span class="number">0x0004</span>) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u32</span>;<span class="comment">//进行优先级判定，只有优先级比这个寄存器里面的值大才能向CPU传递</span></span><br><span class="line"><span class="keyword">const</span> GICC_BPR: *<span class="keyword">mut</span> <span class="type">u32</span> = (GICC_BASE + <span class="number">0x0008</span>) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u32</span>;<span class="comment">//对优先级规则的细化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> GICC_CTLR_ENABLE: <span class="type">u32</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> GICC_CTLR_DISABLE: <span class="type">u32</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Priority Mask Register. interrupt priority filter, Higher priority corresponds to a lower Priority field value.</span></span><br><span class="line"><span class="keyword">const</span> GICC_PMR_PRIO_LOW: <span class="type">u32</span> = <span class="number">0xff</span>;</span><br><span class="line"><span class="comment">// The register defines the point at which the priority value fields split into two parts,</span></span><br><span class="line"><span class="comment">// the group priority field and the subpriority field. The group priority field is used to</span></span><br><span class="line"><span class="comment">// determine interrupt preemption. NO GROUP.</span></span><br><span class="line"><span class="keyword">const</span> GICC_BPR_NO_GROUP: <span class="type">u32</span> = <span class="number">0x00</span>;</span><br></pre></td></tr></table></figure>
<p>接下来就要实现方法函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::arch::asm;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init_gicv2</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化Gicv2的distributor和cpu interface</span></span><br><span class="line">    <span class="comment">// 禁用distributor和cpu interface后进行相应配置</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        ptr::<span class="title function_ invoke__">write_volatile</span>(GICD_CTLR, GICD_CTLR_DISABLE);<span class="comment">//禁用distributor</span></span><br><span class="line">        ptr::<span class="title function_ invoke__">write_volatile</span>(GICC_CTLR, GICC_CTLR_DISABLE);<span class="comment">//禁用interface</span></span><br><span class="line">        ptr::<span class="title function_ invoke__">write_volatile</span>(GICC_PMR, GICC_PMR_PRIO_LOW);<span class="comment">//修改优先级</span></span><br><span class="line">        ptr::<span class="title function_ invoke__">write_volatile</span>(GICC_BPR, GICC_BPR_NO_GROUP);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用distributor和cpu interface</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        ptr::<span class="title function_ invoke__">write_volatile</span>(GICD_CTLR, GICD_CTLR_ENABLE);<span class="comment">//重新启用d</span></span><br><span class="line">        ptr::<span class="title function_ invoke__">write_volatile</span>(GICC_CTLR, GICC_CTLR_ENABLE);<span class="comment">//重新启用c</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 电平触发</span></span><br><span class="line">    <span class="keyword">const</span> ICFGR_LEVEL: <span class="type">u32</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 时钟中断号30</span></span><br><span class="line">    <span class="keyword">const</span> TIMER_IRQ: <span class="type">u32</span> = <span class="number">30</span>;</span><br><span class="line">    <span class="title function_ invoke__">set_config</span>(TIMER_IRQ, ICFGR_LEVEL); <span class="comment">//电平触发</span></span><br><span class="line">    <span class="title function_ invoke__">set_priority</span>(TIMER_IRQ, <span class="number">0</span>); <span class="comment">//优先级设定</span></span><br><span class="line">    <span class="title function_ invoke__">clear</span>(TIMER_IRQ); <span class="comment">//清除时钟中断请求</span></span><br><span class="line">    <span class="title function_ invoke__">enable</span>(TIMER_IRQ); <span class="comment">//使能中断</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//配置timer</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(<span class="string">&quot;mrs x1, CNTFRQ_EL0&quot;</span>); <span class="comment">//读取系统频率</span></span><br><span class="line">        asm!(<span class="string">&quot;msr CNTP_TVAL_EL0, x1&quot;</span>);  <span class="comment">//设置定时寄存器</span></span><br><span class="line">        asm!(<span class="string">&quot;mov x0, 1&quot;</span>);</span><br><span class="line">        asm!(<span class="string">&quot;msr CNTP_CTL_EL0, x0&quot;</span>); <span class="comment">//enable=1, imask=0, istatus= 0,</span></span><br><span class="line">        asm!(<span class="string">&quot;msr daifclr, #2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使能中断号为interrupt的中断</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">enable</span>(interrupt: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        ptr::<span class="title function_ invoke__">write_volatile</span>(</span><br><span class="line">            GICD_ISENABLER.<span class="title function_ invoke__">add</span>((interrupt / GICD_ISENABLER_SIZE) <span class="keyword">as</span> <span class="type">usize</span>),</span><br><span class="line">            <span class="number">1</span> &lt;&lt; (interrupt % GICD_ISENABLER_SIZE)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用中断号为interrupt的中断</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">disable</span>(interrupt: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        ptr::<span class="title function_ invoke__">write_volatile</span>(</span><br><span class="line">            GICD_ICENABLER.<span class="title function_ invoke__">add</span>((interrupt / GICD_ICENABLER_SIZE) <span class="keyword">as</span> <span class="type">usize</span>),</span><br><span class="line">            <span class="number">1</span> &lt;&lt; (interrupt % GICD_ICENABLER_SIZE)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除中断号为interrupt的中断</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">clear</span>(interrupt: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        ptr::<span class="title function_ invoke__">write_volatile</span>(</span><br><span class="line">            GICD_ICPENDR.<span class="title function_ invoke__">add</span>((interrupt / GICD_ICPENDR_SIZE) <span class="keyword">as</span> <span class="type">usize</span>),</span><br><span class="line">            <span class="number">1</span> &lt;&lt; (interrupt % GICD_ICPENDR_SIZE)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置中断号为interrupt的中断的优先级为priority</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_priority</span>(interrupt: <span class="type">u32</span>, priority: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">shift</span> = (interrupt % GICD_IPRIORITY_SIZE) * GICD_IPRIORITY_BITS;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">addr</span>: *<span class="keyword">mut</span> <span class="type">u32</span> = GICD_IPRIORITYR.<span class="title function_ invoke__">add</span>((interrupt / GICD_IPRIORITY_SIZE) <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">value</span>: <span class="type">u32</span> = ptr::<span class="title function_ invoke__">read_volatile</span>(addr);</span><br><span class="line">        value &amp;= !(<span class="number">0xff</span> &lt;&lt; shift);</span><br><span class="line">        value |= priority &lt;&lt; shift;</span><br><span class="line">        ptr::<span class="title function_ invoke__">write_volatile</span>(addr, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置中断号为interrupt的中断的属性为config</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_config</span>(interrupt: <span class="type">u32</span>, config: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">shift</span> = (interrupt % GICD_ICFGR_SIZE) * GICD_ICFGR_BITS;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">addr</span>: *<span class="keyword">mut</span> <span class="type">u32</span> = GICD_ICFGR.<span class="title function_ invoke__">add</span>((interrupt / GICD_ICFGR_SIZE) <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">value</span>: <span class="type">u32</span> = ptr::<span class="title function_ invoke__">read_volatile</span>(addr);</span><br><span class="line">        value &amp;= !(<span class="number">0x03</span> &lt;&lt; shift);</span><br><span class="line">        value |= config &lt;&lt; shift;</span><br><span class="line">        ptr::<span class="title function_ invoke__">write_volatile</span>(addr, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化</li>
<li>使能</li>
<li>停止</li>
<li>清零</li>
<li>设置优先级</li>
<li>设置属性</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::arch::global_asm;</span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;exceptions.s&quot;</span>));<span class="comment">//定义错误的内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span><span class="comment">//C语言格式对齐</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ExceptionCtx</span> &#123;<span class="comment">//保存寄存器的状态和值</span></span><br><span class="line">    regs: [<span class="type">u64</span>; <span class="number">30</span>],</span><br><span class="line">    elr_el1: <span class="type">u64</span>,</span><br><span class="line">    spsr_el1: <span class="type">u64</span>,</span><br><span class="line">    lr: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对各种的名称的引用，具体信息放在exception</span></span><br><span class="line"><span class="keyword">const</span> EL1_SP0_SYNC: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL1_SP0_SYNC&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> EL1_SP0_IRQ: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL1_SP0_IRQ&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> EL1_SP0_FIQ: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL1_SP0_FIQ&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> EL1_SP0_ERROR: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL1_SP0_ERROR&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> EL1_SYNC: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL1_SYNC&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> EL1_IRQ: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL1_IRQ&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> EL1_FIQ: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL1_FIQ&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> EL1_ERROR: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL1_ERROR&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> EL0_SYNC: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL0_SYNC&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> EL0_IRQ: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL0_IRQ&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> EL0_FIQ: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL0_FIQ&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> EL0_ERROR: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL0_ERROR&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> EL0_32_SYNC: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL0_32_SYNC&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> EL0_32_IRQ: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL0_32_IRQ&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> EL0_32_FIQ: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL0_32_FIQ&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> EL0_32_ERROR: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;EL0_32_ERROR&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用我们的print!宏打印异常信息，你也可以选择打印异常发生时所有寄存器的信息</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">catch</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx, name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    crate::<span class="built_in">print!</span>(</span><br><span class="line">        <span class="string">&quot;\n  \</span></span><br><span class="line"><span class="string">        &#123;&#125; @ 0x&#123;:016x&#125;\n\n &quot;</span>,</span><br><span class="line">        name,</span><br><span class="line">        ctx.elr_el1,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span><span class="comment">//不改变函数名称</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el1_sp0_sync</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL1_SP0_SYNC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el1_sp0_irq</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL1_SP0_IRQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el1_sp0_fiq</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL1_SP0_FIQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el1_sp0_error</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL1_SP0_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el1_sync</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL1_SYNC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el1_irq</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL1_IRQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el1_fiq</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL1_FIQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el1_error</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL1_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el0_sync</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL0_SYNC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el0_irq</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL0_IRQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el0_fiq</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL0_FIQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el0_error</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL0_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el0_32_sync</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL0_32_SYNC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el0_32_irq</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL0_32_IRQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el0_32_fiq</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL0_32_FIQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el0_32_error</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL0_32_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了定义错误的情况我们构建异常向量表，具体信息放在exceptions里面</p>
<p>而具体内容是在手册上，根据老师的内容写了</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT OR Apache-2.0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Copyright (c) 2018-2021 Andre Richter &lt;andre.o.richter@gmail.com&gt;</span></span><br><span class="line"></span><br><span class="line">.<span class="keyword">extern</span> el1_sp0_sync</span><br><span class="line">.<span class="keyword">extern</span> el1_sp0_irq</span><br><span class="line">.<span class="keyword">extern</span> el1_sp0_fiq</span><br><span class="line">.<span class="keyword">extern</span> el1_sp0_error</span><br><span class="line">.<span class="keyword">extern</span> el1_sync</span><br><span class="line">.<span class="keyword">extern</span> el1_irq</span><br><span class="line">.<span class="keyword">extern</span> el1_fiq</span><br><span class="line">.<span class="keyword">extern</span> el1_error</span><br><span class="line">.<span class="keyword">extern</span> el0_sync</span><br><span class="line">.<span class="keyword">extern</span> el0_irq</span><br><span class="line">.<span class="keyword">extern</span> el0_fiq</span><br><span class="line">.<span class="keyword">extern</span> el0_error</span><br><span class="line">.<span class="keyword">extern</span> el0_32_sync</span><br><span class="line">.<span class="keyword">extern</span> el0_32_irq</span><br><span class="line">.<span class="keyword">extern</span> el0_32_fiq</span><br><span class="line">.<span class="keyword">extern</span> el0_32_error</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Definitions</span></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Call the function provided by parameter `\handler` after saving the exception context. Provide</span></span><br><span class="line"><span class="comment">/// the context as the first parameter to &#x27;\handler&#x27;.</span></span><br><span class="line">.equ CONTEXT_SIZE, <span class="number">264</span></span><br><span class="line"></span><br><span class="line">.section .text.exceptions</span><br><span class="line"></span><br><span class="line">.<span class="keyword">macro</span> EXCEPTION_VECTOR handler</span><br><span class="line">    sub sp, sp, #CONTEXT_SIZE</span><br><span class="line"></span><br><span class="line"><span class="comment">// store general purpose registers</span></span><br><span class="line">    stp x0, x1, [sp, #<span class="number">16</span> * <span class="number">0</span>]</span><br><span class="line">    stp x2, x3, [sp, #<span class="number">16</span> * <span class="number">1</span>]</span><br><span class="line">    stp x4, x5, [sp, #<span class="number">16</span> * <span class="number">2</span>]</span><br><span class="line">    stp x6, x7, [sp, #<span class="number">16</span> * <span class="number">3</span>]</span><br><span class="line">    stp x8, x9, [sp, #<span class="number">16</span> * <span class="number">4</span>]</span><br><span class="line">    stp x10, x11, [sp, #<span class="number">16</span> * <span class="number">5</span>]</span><br><span class="line">    stp x12, x13, [sp, #<span class="number">16</span> * <span class="number">6</span>]</span><br><span class="line">    stp x14, x15, [sp, #<span class="number">16</span> * <span class="number">7</span>]</span><br><span class="line">    stp x16, x17, [sp, #<span class="number">16</span> * <span class="number">8</span>]</span><br><span class="line">    stp x18, x19, [sp, #<span class="number">16</span> * <span class="number">9</span>]</span><br><span class="line">    stp x20, x21, [sp, #<span class="number">16</span> * <span class="number">10</span>]</span><br><span class="line">    stp x22, x23, [sp, #<span class="number">16</span> * <span class="number">11</span>]</span><br><span class="line">    stp x24, x25, [sp, #<span class="number">16</span> * <span class="number">12</span>]</span><br><span class="line">    stp x26, x27, [sp, #<span class="number">16</span> * <span class="number">13</span>]</span><br><span class="line">    stp x28, x29, [sp, #<span class="number">16</span> * <span class="number">14</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// store exception link register and saved processor state register</span></span><br><span class="line">    mrs x0, elr_el1</span><br><span class="line">    mrs x1, spsr_el1</span><br><span class="line">    stp x0, x1, [sp, #<span class="number">16</span> * <span class="number">15</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// store link register which is x30</span></span><br><span class="line">    <span class="type">str</span> x30, [sp, #<span class="number">16</span> * <span class="number">16</span>]</span><br><span class="line">    mov x0, sp</span><br><span class="line"></span><br><span class="line"><span class="comment">// call exception handler</span></span><br><span class="line">    bl \handler</span><br><span class="line"></span><br><span class="line"><span class="comment">// exit exception</span></span><br><span class="line">    b .exit_exception</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Private Code</span></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// The exception vector table.</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/** When an exception occurs, the processor must execute handler code that corresponds to the exception.</span></span><br><span class="line"><span class="comment">The location in memory where the handler is stored is called the exception vector. In the ARM architecture,</span></span><br><span class="line"><span class="comment">exception vectors are stored in a table, called the exception vector table.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Each Exception level has its own vector table, that is, there is one for each of EL3, EL2, and EL1. The table contains</span></span><br><span class="line"><span class="comment">instructions to be executed, rather than a set of addresses. These would normally be branch instructions that direct the</span></span><br><span class="line"><span class="comment">core to the full exception handler.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The exception vector table for EL1, for example, holds instructions for handling all types of exception that can occur at EL1,</span></span><br><span class="line"><span class="comment">Vectors for individual exceptions are at fixed offsets from the beginning of the table. The virtual address of each table base</span></span><br><span class="line"><span class="comment">is set by the Vector Based Address Registers: VBAR_EL3, VBAR_EL2 and VBAR_EL1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Each entry in the vector table is 16 instructions long (in ARMv7-A and AArch32, each entry is only 4 bytes). This means that in</span></span><br><span class="line"><span class="comment">AArch64 the top-level handler can be written directly in the vector table.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The base address is given by VBAR_ELn and each entry has a defined offset from this base address. Each table has 16 entries,</span></span><br><span class="line"><span class="comment">with each entry being 128 bytes (32 instructions) in size. The table effectively consists of 4 sets of 4 entries. Which entry</span></span><br><span class="line"><span class="comment">is used depends on several factors:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The type of exception (SError, FIQ, IRQ, or Synchronous)</span></span><br><span class="line"><span class="comment">If the exception is being taken at the same Exception level, the stack pointer to be used (SP0 or SPn)</span></span><br><span class="line"><span class="comment">If the exception is being taken at a lower Exception level, the Execution state of the next lower level (AArch64 or AArch32).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.section .text.exceptions_vector_table</span><br><span class="line"><span class="comment">// Export a symbol for the Rust code to use.</span></span><br><span class="line">.globl exception_vector_table</span><br><span class="line">exception_vector_table:</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0000</span></span><br><span class="line">    EXCEPTION_VECTOR el1_sp0_sync</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0080</span></span><br><span class="line">    EXCEPTION_VECTOR el1_sp0_irq</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0100</span></span><br><span class="line">    EXCEPTION_VECTOR el1_sp0_fiq</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0180</span></span><br><span class="line">    EXCEPTION_VECTOR el1_sp0_error</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0200</span></span><br><span class="line">    EXCEPTION_VECTOR el1_sync</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0280</span></span><br><span class="line">    EXCEPTION_VECTOR el1_irq</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0300</span></span><br><span class="line">    EXCEPTION_VECTOR el1_fiq</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0380</span></span><br><span class="line">    EXCEPTION_VECTOR el1_error</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0400</span></span><br><span class="line">    EXCEPTION_VECTOR el0_sync</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0480</span></span><br><span class="line">    EXCEPTION_VECTOR el0_irq</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0500</span></span><br><span class="line">    EXCEPTION_VECTOR el0_fiq</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0580</span></span><br><span class="line">    EXCEPTION_VECTOR el0_error</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0600</span></span><br><span class="line">    EXCEPTION_VECTOR el0_32_sync</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0680</span></span><br><span class="line">    EXCEPTION_VECTOR el0_32_irq</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0700</span></span><br><span class="line">    EXCEPTION_VECTOR el0_32_fiq</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0780</span></span><br><span class="line">    EXCEPTION_VECTOR el0_32_error</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x0800</span></span><br><span class="line"></span><br><span class="line">.exit_exception:</span><br><span class="line"><span class="comment">// restore link register</span></span><br><span class="line">    ldr x30, [sp, #<span class="number">16</span> * <span class="number">16</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// restore exception link register and saved processor state register</span></span><br><span class="line">    ldp x0, x1, [sp, #<span class="number">16</span> * <span class="number">15</span>]</span><br><span class="line">    msr elr_el1, x0</span><br><span class="line">    msr spsr_el1, x1</span><br><span class="line"></span><br><span class="line"><span class="comment">// restore general purpose registers</span></span><br><span class="line">    ldp x28, x29, [sp, #<span class="number">16</span> * <span class="number">14</span>]</span><br><span class="line">    ldp x26, x27, [sp, #<span class="number">16</span> * <span class="number">13</span>]</span><br><span class="line">    ldp x24, x25, [sp, #<span class="number">16</span> * <span class="number">12</span>]</span><br><span class="line">    ldp x22, x23, [sp, #<span class="number">16</span> * <span class="number">11</span>]</span><br><span class="line">    ldp x20, x21, [sp, #<span class="number">16</span> * <span class="number">10</span>]</span><br><span class="line">    ldp x18, x19, [sp, #<span class="number">16</span> * <span class="number">9</span>]</span><br><span class="line">    ldp x16, x17, [sp, #<span class="number">16</span> * <span class="number">8</span>]</span><br><span class="line">    ldp x14, x15, [sp, #<span class="number">16</span> * <span class="number">7</span>]</span><br><span class="line">    ldp x12, x13, [sp, #<span class="number">16</span> * <span class="number">6</span>]</span><br><span class="line">    ldp x10, x11, [sp, #<span class="number">16</span> * <span class="number">5</span>]</span><br><span class="line">    ldp x8, x9, [sp, #<span class="number">16</span> * <span class="number">4</span>]</span><br><span class="line">    ldp x6, x7, [sp, #<span class="number">16</span> * <span class="number">3</span>]</span><br><span class="line">    ldp x4, x5, [sp, #<span class="number">16</span> * <span class="number">2</span>]</span><br><span class="line">    ldp x2, x3, [sp, #<span class="number">16</span> * <span class="number">1</span>]</span><br><span class="line">    ldp x0, x1, [sp, #<span class="number">16</span> * <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// restore stack pointer</span></span><br><span class="line">    add sp, sp, #CONTEXT_SIZE</span><br><span class="line">    eret</span><br></pre></td></tr></table></figure>
<p>为了引入异常向量表在初始化也就是start.s中加入以下代码来载入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">        mov     sp, x30</span><br><span class="line"></span><br><span class="line">        // Initialize exceptions</span><br><span class="line">        ldr     x0, =exception_vector_table</span><br><span class="line">        msr     vbar_el1, x0</span><br><span class="line">        isb</span><br><span class="line"></span><br><span class="line">        bl      not_main</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<p>同样为了连接器能够识别并链接异常向量表要在ld文件中加入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">    .text.boot : &#123; *(.text.boot) &#125;</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        KEEP(*(.text.boot))</span><br><span class="line">        *(.text.exceptions)</span><br><span class="line">        . = ALIGN(4096); /* align for exceptions_vector_table*/</span><br><span class="line">        *(.text.exceptions_vector_table)</span><br><span class="line">        *(.text)</span><br><span class="line">    &#125;</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<p>编辑src/main.rs，引入interrupts.rs模块，并在not_main()函数中注释掉之前的hello world输出代码，调用init_gicv2()函数</p>
<h2 id="调试">调试</h2>
<p><code>cargo build &amp;&amp; qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -S -s</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-elf-gdb target/aarch64-unknown-none-softfloat/debug/rui_armv8_os</span><br><span class="line">target remote localhost:1234</span><br><span class="line">b not_main</span><br></pre></td></tr></table></figure>
<p>运行到interrupts::init_gicv2();语句之前。</p>
<p><code>n</code></p>
<p>查看0x08000100地址中的值，</p>
<p><code>x/t 0x08000100</code></p>
<h1>为了消除警告做进一步的修改</h1>
<p>虽然到这里我们可以成功编译运行，但是很明显是很有问题的，就是很多警告，有警告看上去就很危险，这是我们不希望的，于是我借鉴了一些别人的操作进行了一定的修改</p>
<hr>
<p><em><strong>能跑就行，程序和你其中一个能跑就行——约尔·佛杰</strong></em></p>
<hr>
<p>在 <code>interupts.rs</code>中我们为了和实际的硬件相联系，于是穷举了所有的情况并且设置了很多的常数以及指针，但是这些内容并不是随时都用到的，在这些值没有使用的时候称为<strong>dead code</strong>就没有用过，在rust中认为申明了不用是一种可耻的行为于是会产生警告，为此我们在 <code>main.rs</code>中加入</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code)]</span> <span class="comment">// 忽略dead_code</span></span><br></pre></td></tr></table></figure>
<p>这样我们的警告就已经消失的差不多了，再来看第二个问题就是说，我们的时钟中断就仅仅中断了一次，没有实现定时中断的效果，为了实现这个效果我找别人问了一下<s>抄了一下</s>在 <code>init_gicv2()</code>函数后面加上了</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(<span class="string">&quot;mrs x0, CNTPCT_EL0&quot;</span>); <span class="comment">// 系统计数器</span></span><br><span class="line">        asm!(<span class="string">&quot;mrs x0, CNTP_CTL_EL0&quot;</span>); <span class="comment">// 控制计数器</span></span><br><span class="line">        asm!(<span class="string">&quot;mrs x0, CNTP_TVAL_EL0&quot;</span>); <span class="comment">// 定时计数器</span></span><br><span class="line">        asm!(<span class="string">&quot;mrs x0, CNTP_CVAL_EL0&quot;</span>); <span class="comment">// 比较计数器</span></span><br><span class="line">        asm!(<span class="string">&quot;wfi&quot;</span>); <span class="comment">// Wait for Interrupt 等待中断，下一次中断发生前都停止在此处</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是不行，本来应该行的，就是发现做完第一次之后发生了阻塞，不懂是不是因为无限循环 <code>loop</code>最后的解决方法是</p>
<p>在 <code>config.toml</code>里面改成</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[unstable]</span><br><span class="line">build-std = [<span class="string">&quot;core&quot;</span>, <span class="string">&quot;compiler_builtins&quot;</span>] </span><br><span class="line"></span><br><span class="line">[build]</span><br><span class="line">target = <span class="string">&quot;aarch64-unknown-none-softfloat&quot;</span></span><br><span class="line">rustflags = [<span class="string">&quot;-C&quot;</span>,<span class="string">&quot;link-arg=-Taarch64-qemu.ld&quot;</span>, <span class="string">&quot;-C&quot;</span>, <span class="string">&quot;target-cpu=cortex-a53&quot;</span>, <span class="string">&quot;-D&quot;</span>, <span class="string">&quot;warnings&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>这样就可以了，与此同时对于我们输出中断类型的方式也要做一点修改</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//interupts.rs</span></span><br><span class="line"><span class="comment">// 调用我们的print!宏打印异常信息，你也可以选择打印异常发生时所有寄存器的信息</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">catch</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx, name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    crate::<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;\n&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终我们会发现显示屏上不断输出 <code>EL1_IRQ</code></p>
<p>对于<strong>ARM架构</strong>的芯片来说，其中的时钟延时中断是由内置的比较寄存器来实现的，当时钟计数超过了这个比较寄存器就会发生定时中断，为了达到这个效果我们要在 <code>EL1_IRQ</code>(一级中断)里面进行一定的设置</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el1_sp0_irq</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="title function_ invoke__">catch</span>(ctx, EL1_SP0_IRQ);</span><br><span class="line"></span><br><span class="line">    asm!(<span class="string">&quot;mrs x1, CNTFRQ_EL0&quot;</span>);</span><br><span class="line">    asm!(<span class="string">&quot;msr CNTP_TVAL_EL0, x1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说在实现一级中断的时候要向已经清零的比较寄存器里面再次写入我们希望的时间间隔，这样就可以产生延时中断了</p>
<h2 id="重构代码">重构代码</h2>
<p><em><strong>优化代码，重构一下，麻烦了自己……，也不会方便他人，嗯，就是麻烦了自己——爱德华·艾力克</strong></em></p>
<hr>
<p>由于我们在之前为了实现中断，我们写了很多的寄存器映射以及常数以及指针以及字符串，这个比较绕，而且容易出错，于是我们对代码进行一遍重构</p>
<p>在 <code>Cargo.toml</code>中加入新的依赖 <code>tock-registers = &quot;0.7.0&quot;</code></p>
<p>这个东西官网是这么描述的</p>
<blockquote>
<p>Provides efficient mechanisms to express and use type-checked memory mapped registers and bitfields.</p>
</blockquote>
<br/>
<h1>有输出就有输入</h1>
<p>我们要进一步完善我们的嵌入式操作系统virt，终于到了实现输入的时候</p>
<p>首先我们应该明确在我们的操作系统中很多的内容都应该是和中断相关的，很显然这里也是如此，简单来说我们需要实现一个输入中断</p>
<p>这个过程应该是分为两部分的，一方面我们要接收数据，另一方面我们要把接受到的数据打印到屏幕上面来告诉我们，这个数据确实已经被接受到了</p>
<p>在之前我们实现打印的过程中，我们了解到vert的pl011串口，并且通过直接修改内存地址映射的方式实现了打印，QEMU的virt机器默认没有键盘作为输入设备，但当我们执行QEMU使用-nographic参数（Disable graphical output and redirect serial I/Os to console）时QEMU会将串口重定向到控制台，因此我们可以使用UART(异步收发传输器)作为输入设备。</p>
<p>第一步就是要把所有的设备寄存器映射到内存地址空间，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tock_registers::&#123;registers::&#123;ReadOnly, ReadWrite, WriteOnly&#125;, register_bitfields, register_structs&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> PL011REGS: *<span class="keyword">mut</span> PL011Regs = (<span class="number">0x0900_0000</span>) <span class="keyword">as</span> *<span class="keyword">mut</span> PL011Regs;</span><br><span class="line"></span><br><span class="line">register_bitfields![</span><br><span class="line">    <span class="type">u32</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> UARTDR [</span><br><span class="line">        DATA <span class="title function_ invoke__">OFFSET</span>(<span class="number">0</span>) <span class="title function_ invoke__">NUMBITS</span>(<span class="number">8</span>) []</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">/// Flag Register</span></span><br><span class="line">    <span class="keyword">pub</span> UARTFR [</span><br><span class="line">        <span class="comment">/// Transmit FIFO full. The meaning of this bit depends on the</span></span><br><span class="line">        <span class="comment">/// state of the FEN bit in the UARTLCR_ LCRH Register. If the</span></span><br><span class="line">        <span class="comment">/// FIFO is disabled, this bit is set when the transmit</span></span><br><span class="line">        <span class="comment">/// holding register is full. If the FIFO is enabled, the TXFF</span></span><br><span class="line">        <span class="comment">/// bit is set when the transmit FIFO is full.</span></span><br><span class="line">        TXFF <span class="title function_ invoke__">OFFSET</span>(<span class="number">6</span>) <span class="title function_ invoke__">NUMBITS</span>(<span class="number">1</span>) [],</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// Receive FIFO empty. The meaning of this bit depends on the</span></span><br><span class="line">        <span class="comment">/// state of the FEN bit in the UARTLCR_H Register. If the</span></span><br><span class="line">        <span class="comment">/// FIFO is disabled, this bit is set when the receive holding</span></span><br><span class="line">        <span class="comment">/// register is empty. If the FIFO is enabled, the RXFE bit is</span></span><br><span class="line">        <span class="comment">/// set when the receive FIFO is empty.</span></span><br><span class="line">        RXFE <span class="title function_ invoke__">OFFSET</span>(<span class="number">4</span>) <span class="title function_ invoke__">NUMBITS</span>(<span class="number">1</span>) []</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Integer Baud rate divisor</span></span><br><span class="line">    <span class="keyword">pub</span> UARTIBRD [</span><br><span class="line">        <span class="comment">/// Integer Baud rate divisor</span></span><br><span class="line">        IBRD <span class="title function_ invoke__">OFFSET</span>(<span class="number">0</span>) <span class="title function_ invoke__">NUMBITS</span>(<span class="number">16</span>) []</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Fractional Baud rate divisor</span></span><br><span class="line">    <span class="keyword">pub</span> UARTFBRD [</span><br><span class="line">        <span class="comment">/// Fractional Baud rate divisor</span></span><br><span class="line">        FBRD <span class="title function_ invoke__">OFFSET</span>(<span class="number">0</span>) <span class="title function_ invoke__">NUMBITS</span>(<span class="number">6</span>) []</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Line Control register</span></span><br><span class="line">    <span class="keyword">pub</span> UARTLCR_H [</span><br><span class="line">        <span class="comment">/// Parity enable. If this bit is set to 1, parity checking and generation</span></span><br><span class="line">        <span class="comment">/// is enabled, else parity is disabled and no parity bit added to the data frame.</span></span><br><span class="line">        PEN <span class="title function_ invoke__">OFFSET</span>(<span class="number">1</span>) <span class="title function_ invoke__">NUMBITS</span>(<span class="number">1</span>) [</span><br><span class="line">            Disabled = <span class="number">0</span>,</span><br><span class="line">            Enabled = <span class="number">1</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">/// Two stop bits select. If this bit is set to 1, two stop bits are transmitted</span></span><br><span class="line">        <span class="comment">/// at the end of the frame.</span></span><br><span class="line">        STP2 <span class="title function_ invoke__">OFFSET</span>(<span class="number">3</span>) <span class="title function_ invoke__">NUMBITS</span>(<span class="number">1</span>) [</span><br><span class="line">            Stop1 = <span class="number">0</span>,</span><br><span class="line">            Stop2 = <span class="number">1</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">/// Enable FIFOs.</span></span><br><span class="line">        FEN <span class="title function_ invoke__">OFFSET</span>(<span class="number">4</span>) <span class="title function_ invoke__">NUMBITS</span>(<span class="number">1</span>) [</span><br><span class="line">            Disabled = <span class="number">0</span>,</span><br><span class="line">            Enabled = <span class="number">1</span></span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// Word length. These bits indicate the number of data bits</span></span><br><span class="line">        <span class="comment">/// transmitted or received in a frame.</span></span><br><span class="line">        WLEN <span class="title function_ invoke__">OFFSET</span>(<span class="number">5</span>) <span class="title function_ invoke__">NUMBITS</span>(<span class="number">2</span>) [</span><br><span class="line">            FiveBit = <span class="number">0b00</span>,</span><br><span class="line">            SixBit = <span class="number">0b01</span>,</span><br><span class="line">            SevenBit = <span class="number">0b10</span>,</span><br><span class="line">            EightBit = <span class="number">0b11</span></span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Control Register</span></span><br><span class="line">    <span class="keyword">pub</span> UARTCR [</span><br><span class="line">        <span class="comment">/// Receive enable. If this bit is set to 1, the receive</span></span><br><span class="line">        <span class="comment">/// section of the UART is enabled. Data reception occurs for</span></span><br><span class="line">        <span class="comment">/// UART signals. When the UART is disabled in the middle of</span></span><br><span class="line">        <span class="comment">/// reception, it completes the current character before</span></span><br><span class="line">        <span class="comment">/// stopping.</span></span><br><span class="line">        RXE    <span class="title function_ invoke__">OFFSET</span>(<span class="number">9</span>) <span class="title function_ invoke__">NUMBITS</span>(<span class="number">1</span>) [</span><br><span class="line">            Disabled = <span class="number">0</span>,</span><br><span class="line">            Enabled = <span class="number">1</span></span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// Transmit enable. If this bit is set to 1, the transmit</span></span><br><span class="line">        <span class="comment">/// section of the UART is enabled. Data transmission occurs</span></span><br><span class="line">        <span class="comment">/// for UART signals. When the UART is disabled in the middle</span></span><br><span class="line">        <span class="comment">/// of transmission, it completes the current character before</span></span><br><span class="line">        <span class="comment">/// stopping.</span></span><br><span class="line">        TXE    <span class="title function_ invoke__">OFFSET</span>(<span class="number">8</span>) <span class="title function_ invoke__">NUMBITS</span>(<span class="number">1</span>) [</span><br><span class="line">            Disabled = <span class="number">0</span>,</span><br><span class="line">            Enabled = <span class="number">1</span></span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// UART enable</span></span><br><span class="line">        UARTEN <span class="title function_ invoke__">OFFSET</span>(<span class="number">0</span>) <span class="title function_ invoke__">NUMBITS</span>(<span class="number">1</span>) [</span><br><span class="line">            <span class="comment">/// If the UART is disabled in the middle of transmission</span></span><br><span class="line">            <span class="comment">/// or reception, it completes the current character</span></span><br><span class="line">            <span class="comment">/// before stopping.</span></span><br><span class="line">            Disabled = <span class="number">0</span>,</span><br><span class="line">            Enabled = <span class="number">1</span></span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> UARTIMSC [</span><br><span class="line">        RXIM <span class="title function_ invoke__">OFFSET</span>(<span class="number">4</span>) <span class="title function_ invoke__">NUMBITS</span>(<span class="number">1</span>) [</span><br><span class="line">            Disabled = <span class="number">0</span>,</span><br><span class="line">            Enabled = <span class="number">1</span></span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">/// Interupt Clear Register</span></span><br><span class="line">    <span class="keyword">pub</span> UARTICR [</span><br><span class="line">        <span class="comment">/// Meta field for all pending interrupts</span></span><br><span class="line">        ALL <span class="title function_ invoke__">OFFSET</span>(<span class="number">0</span>) <span class="title function_ invoke__">NUMBITS</span>(<span class="number">11</span>) [</span><br><span class="line">            Clear = <span class="number">0x7ff</span></span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">register_structs! &#123;</span><br><span class="line">    <span class="keyword">pub</span> PL011Regs &#123;</span><br><span class="line">        (<span class="number">0x00</span> =&gt; <span class="keyword">pub</span> dr: ReadWrite&lt;<span class="type">u32</span>, UARTDR::Register&gt;),                   <span class="comment">// 0x00</span></span><br><span class="line">        (<span class="number">0x04</span> =&gt; __reserved_0),               <span class="comment">// 0x04</span></span><br><span class="line">        (<span class="number">0x18</span> =&gt; <span class="keyword">pub</span> fr: ReadOnly&lt;<span class="type">u32</span>, UARTFR::Register&gt;),      <span class="comment">// 0x18</span></span><br><span class="line">        (<span class="number">0x1c</span> =&gt; __reserved_1),               <span class="comment">// 0x1c</span></span><br><span class="line">        (<span class="number">0x24</span> =&gt; <span class="keyword">pub</span> ibrd: WriteOnly&lt;<span class="type">u32</span>, UARTIBRD::Register&gt;), <span class="comment">// 0x24</span></span><br><span class="line">        (<span class="number">0x28</span> =&gt; <span class="keyword">pub</span> fbrd: WriteOnly&lt;<span class="type">u32</span>, UARTFBRD::Register&gt;), <span class="comment">// 0x28</span></span><br><span class="line">        (<span class="number">0x2C</span> =&gt; <span class="keyword">pub</span> lcr_h: WriteOnly&lt;<span class="type">u32</span>, UARTLCR_H::Register&gt;), <span class="comment">// 0x2C</span></span><br><span class="line">        (<span class="number">0x30</span> =&gt; <span class="keyword">pub</span> cr: WriteOnly&lt;<span class="type">u32</span>, UARTCR::Register&gt;),     <span class="comment">// 0x30</span></span><br><span class="line">        (<span class="number">0x34</span> =&gt; __reserved_2),               <span class="comment">// 0x34</span></span><br><span class="line">        (<span class="number">0x38</span> =&gt; <span class="keyword">pub</span> imsc: ReadWrite&lt;<span class="type">u32</span>, UARTIMSC::Register&gt;), <span class="comment">// 0x38</span></span><br><span class="line">        (<span class="number">0x44</span> =&gt; <span class="keyword">pub</span> icr: WriteOnly&lt;<span class="type">u32</span>, UARTICR::Register&gt;),   <span class="comment">// 0x44</span></span><br><span class="line">        (<span class="number">0x48</span> =&gt; @END),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步我们使用<strong>tock_registers</strong>库完成</p>
<p>完成了内存地址映射之后，我们重新对之前构造的<strong>Writer</strong>进行修改，因为之前我们只用了pl011这个设备寄存器进行输出，而现在我们用到了整个UART进行数据收发</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//嵌入式系统使用串口，而不是vga，直接输出，没有颜色控制，不记录列号，也没有frame buffer，所以采用空结构</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Writer</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往串口寄存器写入字节和字符串进行输出</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write_byte</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, byte: <span class="type">u8</span>) &#123;</span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write_string</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Writer&#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="comment">// pl011 device registers</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">pl011r</span>: &amp;PL011Regs = &amp;*PL011REGS;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 禁用pl011</span></span><br><span class="line">            pl011r.cr.<span class="title function_ invoke__">write</span>(UARTCR::TXE::Disabled + UARTCR::RXE::Disabled + UARTCR::UARTEN::Disabled);</span><br><span class="line">            <span class="comment">// 清空中断状态</span></span><br><span class="line">            pl011r.icr.<span class="title function_ invoke__">write</span>(UARTICR::ALL::Clear);</span><br><span class="line">            <span class="comment">// 设定中断mask，需要使能的中断</span></span><br><span class="line">            pl011r.imsc.<span class="title function_ invoke__">write</span>(UARTIMSC::RXIM::Enabled);</span><br><span class="line">            <span class="comment">// IBRD = UART_CLK / (16 * BAUD_RATE)</span></span><br><span class="line">            <span class="comment">// FBRD = ROUND((64 * MOD(UART_CLK,(16 * BAUD_RATE))) / (16 * BAUD_RATE))</span></span><br><span class="line">            <span class="comment">// UART_CLK = 24M</span></span><br><span class="line">            <span class="comment">// BAUD_RATE = 115200</span></span><br><span class="line">            pl011r.ibrd.<span class="title function_ invoke__">write</span>(UARTIBRD::IBRD.<span class="title function_ invoke__">val</span>(<span class="number">13</span>));</span><br><span class="line">            pl011r.fbrd.<span class="title function_ invoke__">write</span>(UARTFBRD::FBRD.<span class="title function_ invoke__">val</span>(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 8N1 FIFO enable</span></span><br><span class="line">            pl011r.lcr_h.<span class="title function_ invoke__">write</span>(UARTLCR_H::WLEN::EightBit + UARTLCR_H::PEN::Disabled + UARTLCR_H::STP2::Stop1</span><br><span class="line">                + UARTLCR_H::FEN::Enabled);</span><br><span class="line">            <span class="comment">// enable pl011</span></span><br><span class="line">            pl011r.cr.<span class="title function_ invoke__">write</span>(UARTCR::UARTEN::Enabled + UARTCR::RXE::Enabled + UARTCR::TXE::Enabled);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        Writer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">core</span>::fmt::Write <span class="keyword">for</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line"><span class="comment">// ······</span></span><br></pre></td></tr></table></figure>
<p>为空结构体(标志)实现新的<strong>方法</strong></p>
<p>方法中包含了打印和新建，重构<strong>打印</strong>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//嵌入式系统使用串口，而不是vga，直接输出，没有颜色控制，不记录列号，也没有frame buffer，所以采用空结构</span><br><span class="line">pub struct Writer;</span><br><span class="line"></span><br><span class="line">//往串口寄存器写入字节和字符串进行输出</span><br><span class="line">impl Writer &#123;</span><br><span class="line">    pub fn write_byte(&amp;mut self, byte: u8) &#123;</span><br><span class="line">        // const UART0: *mut u8 = 0x0900_0000 as *mut u8;</span><br><span class="line">        unsafe &#123;</span><br><span class="line">            // pl011 device registers</span><br><span class="line">            let pl011r: &amp;PL011Regs = &amp;*PL011REGS;</span><br><span class="line">  </span><br><span class="line">            // ptr::write_volatile(UART0, byte);</span><br><span class="line">            pl011r.dr.write(UARTDR::DATA.val(byte as u32));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn write_string(&amp;mut self, s: &amp;str) &#123;</span><br><span class="line">    // ······</span><br></pre></td></tr></table></figure>
<p>以上就是我们实现数据显现的过程也就是第二部分的内容，接下来处理数据接受的问题</p>
<p>一开始我们应该在<strong><a target="_blank" rel="noopener" href="http://interrupts.rs">interrupts.rs</a></strong>(中断合集)中对数据接受中断进行初始化描述，也就是**init_gicv2()**函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ······</span></span><br><span class="line">    <span class="comment">//配置timer</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化UART0 中断</span></span><br><span class="line">    <span class="comment">// interrupts = &lt;0x00 0x01 0x04&gt;; SPI, 0x01, level</span></span><br><span class="line">    <span class="title function_ invoke__">set_config</span>(UART0_IRQ, ICFGR_LEVEL); <span class="comment">//电平触发</span></span><br><span class="line">    <span class="title function_ invoke__">set_priority</span>(UART0_IRQ, <span class="number">0</span>); <span class="comment">//优先级设定</span></span><br><span class="line">    <span class="comment">// set_core(TIMER_IRQ, 0x1); // 单核实现无需设置中断目标核</span></span><br><span class="line">    <span class="title function_ invoke__">clear</span>(UART0_IRQ); <span class="comment">//清除中断请求</span></span><br><span class="line">    <span class="title function_ invoke__">enable</span>(UART0_IRQ); <span class="comment">//使能中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ······</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">新的代表数据接受中断的常量</span><br><span class="line">// 时钟中断号</span><br><span class="line">const TIMER_IRQ: u32 = 30;</span><br><span class="line">// 设备中断号</span><br><span class="line">const UART0_IRQ: u32 = 33;</span><br></pre></td></tr></table></figure>
<p>在完成初始化之后，还要实现对应的函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tock_registers::interfaces::Readable;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_irq_lines</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx, _core_num: <span class="type">u32</span>, irq_num: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> irq_num == TIMER_IRQ &#123;</span><br><span class="line">        <span class="title function_ invoke__">handle_timer_irq</span>(ctx);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> irq_num == UART0_IRQ &#123;</span><br><span class="line">        <span class="title function_ invoke__">handle_uart0_rx_irq</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">catch</span>(ctx, EL1_IRQ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_timer_irq</span>(_ctx: &amp;<span class="keyword">mut</span> ExceptionCtx)&#123;</span><br><span class="line"></span><br><span class="line">    crate::<span class="built_in">print!</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每2秒产生一次中断</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(<span class="string">&quot;mrs x1, CNTFRQ_EL0&quot;</span>);</span><br><span class="line">        asm!(<span class="string">&quot;add x1, x1, x1&quot;</span>);</span><br><span class="line">        asm!(<span class="string">&quot;msr CNTP_TVAL_EL0, x1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_uart0_rx_irq</span>(_ctx: &amp;<span class="keyword">mut</span> ExceptionCtx)&#123;</span><br><span class="line">    <span class="keyword">use</span> crate::uart_console::pl011::*;</span><br><span class="line"></span><br><span class="line">    crate::<span class="built_in">print!</span>(<span class="string">&quot;\nInput interrupt: &quot;</span>);</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        <span class="comment">// pl011 device registers</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pl011r</span>: &amp;PL011Regs = &amp;*PL011REGS;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">flag</span> = pl011r.fr.<span class="title function_ invoke__">read</span>(UARTFR::RXFE);</span><br><span class="line">        <span class="keyword">while</span> flag != <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">value</span> = pl011r.dr.<span class="title function_ invoke__">read</span>(UARTDR::DATA);</span><br><span class="line"></span><br><span class="line">            crate::<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, value <span class="keyword">as</span> <span class="type">u8</span> <span class="keyword">as</span> <span class="type">char</span>);</span><br><span class="line">            flag = pl011r.fr.<span class="title function_ invoke__">read</span>(UARTFR::RXFE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些函数将会在发生数据接收中断的时候被调用来处理相关的寄存器，接下来处理数据接收中断发生的时候被触发的函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">el1_irq</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx) &#123;</span><br><span class="line">    <span class="comment">// reads this register to obtain the interrupt ID of the signaled interrupt.</span></span><br><span class="line">    <span class="comment">// This read acts as an acknowledge for the interrupt.</span></span><br><span class="line">    <span class="comment">// 中断确认</span></span><br><span class="line">    <span class="keyword">const</span> GICC_IAR: *<span class="keyword">mut</span> <span class="type">u32</span> = (GICC_BASE + <span class="number">0x0c</span>) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">const</span> GICC_EOIR: *<span class="keyword">mut</span> <span class="type">u32</span> = (GICC_BASE + <span class="number">0x10</span>) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span>: <span class="type">u32</span> = ptr::<span class="title function_ invoke__">read_volatile</span>(GICC_IAR);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">irq_num</span>: <span class="type">u32</span> = value &amp; <span class="number">0x1ff</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">core_num</span>: <span class="type">u32</span> = value &amp; <span class="number">0xe00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际处理中断</span></span><br><span class="line">    <span class="title function_ invoke__">handle_irq_lines</span>(ctx, core_num, irq_num);</span><br><span class="line">    <span class="comment">// catch(ctx, EL1_IRQ);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// A processor writes to this register to inform the CPU interface either:</span></span><br><span class="line">    <span class="comment">// • that it has completed the processing of the specified interrupt</span></span><br><span class="line">    <span class="comment">// • in a GICv2 implementation, when the appropriate GICC_CTLR.EOImode bit is set to 1, to indicate that the interface should perform priority drop for the specified interrupt.</span></span><br><span class="line">    <span class="comment">// 标记中断完成，清除相应中断位</span></span><br><span class="line">    ptr::<span class="title function_ invoke__">write_volatile</span>(GICC_EOIR, core_num | irq_num);</span><br><span class="line">    <span class="title function_ invoke__">clear</span>(irq_num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cargo build &amp;&amp; qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/jiang_armv8_os</code>实现之后就可以了</p>
<h1>关机重要的，呃至少能够重启</h1>
<br/>
<hr>
<p>要实现关机必然不可能脱离中断，因为外部IO想要交互最好的方法就是中断</p>
<p>经过查资料，gpio-keys中定义了一个poweroff键，也即gpio-keys是设备pl061的组成部分，现在要做的事情就比较明朗了，首先映射设备寄存器到内存</p>
<p><a target="_blank" rel="noopener" href="http://xn--pl061-fg1hyjoi685evxjq21a70l.rs">新定义一个模块pl061.rs</a></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tock_registers::&#123;registers::&#123;ReadWrite, WriteOnly&#125;, register_bitfields, register_structs&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> PL061REGS: *<span class="keyword">mut</span> PL061Regs = (<span class="number">0x0903_0000</span>) <span class="keyword">as</span> *<span class="keyword">mut</span> PL061Regs;</span><br><span class="line"></span><br><span class="line">register_bitfields![</span><br><span class="line">    <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> GPIOIE [</span><br><span class="line">        IO3 <span class="title function_ invoke__">OFFSET</span>(<span class="number">3</span>) <span class="title function_ invoke__">NUMBITS</span>(<span class="number">1</span>) [</span><br><span class="line">            Disabled = <span class="number">0</span>,</span><br><span class="line">            Enabled = <span class="number">1</span></span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">register_structs! &#123;</span><br><span class="line">    <span class="keyword">pub</span> PL061Regs &#123;</span><br><span class="line">        (<span class="number">0x000</span> =&gt; __reserved_0),                                               <span class="comment">// 0x000</span></span><br><span class="line">        (<span class="number">0x410</span> =&gt; <span class="keyword">pub</span> ie: ReadWrite&lt;<span class="type">u32</span>, GPIOIE::Register&gt;),                   <span class="comment">// 0x410</span></span><br><span class="line">        (<span class="number">0x414</span> =&gt; __reserved_1),                                               <span class="comment">// 0x414</span></span><br><span class="line">        (<span class="number">0x41C</span> =&gt; <span class="keyword">pub</span> ic: WriteOnly&lt;<span class="type">u32</span>&gt;),                                     <span class="comment">// 0x41C</span></span><br><span class="line">        (<span class="number">0x420</span> =&gt; @END),                                                       <span class="comment">// 0x420</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main.rs中引入定义的模块，接下来对新种类的中断在一开始的时候进行初始化(全局变量中断号，设备寄存器初始化)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GPIO_IRQ: <span class="type">u32</span> = <span class="number">39</span>; <span class="comment">// virt.dts interrupts = &lt;0x00 0x07 0x04&gt;; 32 + 0x07 = 39</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init_gicv2</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化Gicv2的distributor和cpu interface</span></span><br><span class="line">    <span class="comment">// 禁用distributor和cpu interface后进行相应配置</span></span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化GPIO中断</span></span><br><span class="line">    <span class="title function_ invoke__">set_config</span>(GPIO_IRQ, ICFGR_LEVEL); <span class="comment">//电平触发</span></span><br><span class="line">    <span class="title function_ invoke__">set_priority</span>(GPIO_IRQ, <span class="number">0</span>); <span class="comment">//优先级设定</span></span><br><span class="line">    <span class="comment">// set_core(TIMER_IRQ, 0x1); // 单核实现无需设置中断目标核</span></span><br><span class="line">    <span class="title function_ invoke__">clear</span>(GPIO_IRQ); <span class="comment">//清除中断请求</span></span><br><span class="line">    <span class="title function_ invoke__">enable</span>(GPIO_IRQ); <span class="comment">//使能中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使能GPIO的poweroff key中断</span></span><br><span class="line">    <span class="keyword">use</span> crate::pl061::*;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pl061r</span>: &amp;PL061Regs = &amp;*PL061REGS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启用pl061 gpio中的3号线中断</span></span><br><span class="line">        pl061r.ie.<span class="title function_ invoke__">write</span>(GPIOIE::IO3::Enabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ······</span></span><br></pre></td></tr></table></figure>
<p>记得还要导入新的设备寄存器内存地址映射</p>
<p><code>use tock_registers::interfaces::Writeable;</code></p>
<p>对中断控制器更新中断的种类</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_irq_lines</span>(ctx: &amp;<span class="keyword">mut</span> ExceptionCtx, _core_num: <span class="type">u32</span>, irq_num: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> irq_num == TIMER_IRQ &#123;</span><br><span class="line">        <span class="title function_ invoke__">handle_timer_irq</span>(ctx);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> irq_num == UART0_IRQ &#123;</span><br><span class="line">        <span class="title function_ invoke__">handle_uart0_rx_irq</span>(ctx);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> irq_num == GPIO_IRQ &#123;</span><br><span class="line">        <span class="title function_ invoke__">handle_gpio_irq</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">catch</span>(ctx, EL1_IRQ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时还有新的中断处理函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_gpio_irq</span>(_ctx: &amp;<span class="keyword">mut</span> ExceptionCtx)&#123;</span><br><span class="line">    <span class="keyword">use</span> crate::pl061::*;</span><br><span class="line">    crate::<span class="built_in">println!</span>(<span class="string">&quot;Power off!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pl061r</span>: &amp;PL061Regs = &amp;*PL061REGS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除中断信号</span></span><br><span class="line">        pl061r.ic.<span class="title function_ invoke__">set</span>(pl061r.ie.<span class="title function_ invoke__">get</span>());</span><br><span class="line">        <span class="comment">// 关机</span></span><br><span class="line">        asm!(<span class="string">&quot;mov w0, #0x18&quot;</span>);</span><br><span class="line">        asm!(<span class="string">&quot;hlt #0xF000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上理论上来说就已经搞定了</p>
<p>为了启用Semihosting功能，在QEMU执行时需要加入 -semihosting 参数</p>
<p><code>cargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/jiang_armv8_os -semihosting</code></p>
<h1>死锁</h1>
<hr>
<p><em><strong>我们总是把修漏洞放到重启功能确认无误之后，你知道吗？——阿姆斯特朗</strong></em></p>
<hr>
<p>死锁不是一种操作系统的结构，是一种常规的bug,他主要表现为进程或线程之间互相竞争锁而导致卡死。</p>
<div class="note info flat"><p>什么是锁</p>
<p>锁这个概念是和并发一块出现的，如果A和B同时存储着C的内容进行修改，本来A应该把C改成D,然后B再把D改成E,如果发生了并发，也就是说B将获得C，然后不可避免导向一个完全错误的结果。</p>
<p>所以我们提出了锁和进程阻塞的概念，当A获得了C的锁，那么这个文件进程B就不能修改，而是睡觉等待A执行完成之后再唤醒B。</p>
</div>
<p>在我们写的系统中，现在可以看见的锁量只有一个，那就是我们为了实现打印实现的全局WRITE实例，谁获得这个实例谁就能打印字符，但是如果我们在打印的过程中发生中断而将CPU交给另外的打印进程，那么A进程由于失去了CPU而陷入沉睡保留锁，B进程获得了CPU但是没有锁就无法进行打印。</p>
<p>这个死锁成立的情况就是</p>
<ul>
<li>A睡着了，等B执行完之后才能唤醒</li>
<li>B醒着但是没有锁，永远不会执行完，锁在睡着的A手中，A在等B。</li>
</ul>
<h2 id="复刻死锁">复刻死锁</h2>
<p>我们在主函数的空循环里面填入打印字符的要求，这会让她保持持有锁打印的状态</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">not_main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\n[0] Hello from Rust!\n&quot;</span>);</span><br><span class="line">    interrupts::<span class="title function_ invoke__">init_gicv2</span>();</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之前为了验证时钟中断，在时钟中断处理函数中加入了打点输出的效果，我们把那个效果恢复一下。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_timer_irq</span>(_ctx: &amp;<span class="keyword">mut</span> ExceptionCtx)&#123;</span><br><span class="line"></span><br><span class="line">    crate::<span class="built_in">print!</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每两秒产生一次中断</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(<span class="string">&quot;mrs x1,CNTFRQ_EL0&quot;</span>);</span><br><span class="line">        asm!(<span class="string">&quot;add x1,x1,x1&quot;</span>);</span><br><span class="line">        asm!(<span class="string">&quot;msr CNTP_TVAL_EL0,x1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样理论上就能触发死锁了。</p>
<h2 id="解决">解决</h2>
<p>我们可以看到问题在于中断转移了CPU的所有权，从而发生死锁。由于我们只是搞一个简单的操作系统，所以我们用一种比较危险的方式来解决这个问题，那就是在输入的时候选择直接关闭中断。</p>
<p>编辑 <code>src/uart_console/mod.rs</code>，引入asm!宏</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ······</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">core</span>::fmt::Write <span class="keyword">for</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::&#123;fmt, arch::asm&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"><span class="keyword">use</span> spin::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> tock_registers::interfaces::Writeable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> pl011;</span><br><span class="line"><span class="keyword">use</span> pl011::*;</span><br><span class="line"><span class="comment">// ······</span></span><br></pre></td></tr></table></figure>
<p>编辑src/uart_console/mod.rs中的_print()函数，在处理输入时先关闭中断，再打开。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ······</span></span><br><span class="line"><span class="comment">/// Prints the given formatted string to the VGA text buffer through the global `WRITER` instance.</span></span><br><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">_print</span>(args: fmt::Arguments) &#123;</span><br><span class="line">    <span class="keyword">use</span> core::fmt::Write;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭d a i f类型的中断</span></span><br><span class="line">        asm!(<span class="string">&quot;msr daifset, #0xf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WRITER.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">write_fmt</span>(args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 仅打开i类型的中断，不支持嵌套，嵌套应该保存状态，然后再恢复之前的状态</span></span><br><span class="line">        asm!(<span class="string">&quot;msr daifclr, #2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我们会发现死锁现象消失。</p>
<h1>结束</h1>
<p>上半部分到此结束，下半部分有时间更新。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="http://tva1.sinaimg.cn/large/008tudqVgy1h554mk0s86j315o0ngqmf.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/article/1482cbf3.html"><img class="prev-cover" src="http://tva1.sinaimg.cn/large/008tudqVgy1h55dlrh99fj339d1jke86.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Rust中的所有权</div></div></a></div><div class="next-post pull-right"><a href="/article/aa70025d.html"><img class="next-cover" src="http://tva1.sinaimg.cn/large/008tudqVgy1h54vrer3rvj32au1duu10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hexo主题Aurora设置数学输入</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sheng xun</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/shengpotxun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/shengpotxun" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">努力学习中，不定期发文</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">安装环境</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">裸机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hello-world"><span class="toc-text">hello world</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%95%88%E5%86%85%E5%AE%B9%EF%BC%8C%E8%A7%A3%E9%87%8A%E4%BA%86%E4%B8%80%E7%82%B9VGA%E5%8E%9F%E7%90%86"><span class="toc-text">无效内容，解释了一点VGA原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">从放弃轮询到写不出中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Distributor%E4%BB%B2%E8%A3%81%E5%99%A8"><span class="toc-text">Distributor仲裁器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-interfacce"><span class="toc-text">CPU interfacce</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-text">过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-text">调试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">为了消除警告做进一步的修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E4%BB%A3%E7%A0%81"><span class="toc-text">重构代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">有输出就有输入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">关机重要的，呃至少能够重启</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%BB%E6%AD%BB%E9%94%81"><span class="toc-text">复刻死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3"><span class="toc-text">解决</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">结束</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/article/1b3bf67a.html" title="人工智能导论(1)——什么是人工智能、agent">人工智能导论(1)——什么是人工智能、agent</a><time datetime="2022-09-05T08:10:40.000Z" title="发表于 2022-09-05 16:10:40">2022-09-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/article/49a284e.html" title="QT串口通信——22湖南大学计算机学院工训大作业">QT串口通信——22湖南大学计算机学院工训大作业</a><time datetime="2022-09-01T15:21:07.000Z" title="发表于 2022-09-01 23:21:07">2022-09-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/article/3d5068ec.html" title="题型——泰勒公式求极限">题型——泰勒公式求极限</a><time datetime="2022-08-23T12:07:14.000Z" title="发表于 2022-08-23 20:07:14">2022-08-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/article/8e4748df.html" title="22湖南大学计算机学院工训后半">22湖南大学计算机学院工训后半</a><time datetime="2022-08-22T15:11:54.000Z" title="发表于 2022-08-22 23:11:54">2022-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/article/daff9eeb.html" title="8个基本等阶无穷小替换与对应泰勒公式">8个基本等阶无穷小替换与对应泰勒公式</a><time datetime="2022-08-21T07:54:08.000Z" title="发表于 2022-08-21 15:54:08">2022-08-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Sheng xun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '7fbd5c09d102c9286a19',
      clientSecret: '0c10d76a590477c2fad2a7ef1638e23595a9cd73',
      repo: 'gittalk',
      owner: 'shengpotxun',
      admin: ['shengpotxun'],
      id: '7ea583e6dfe9b91011e77353f32a97a3',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.16/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?shengpotxun";
            var git_color =['#e4dfd7', '#f9f4dc', '#f7e8aa', '#f7e8aa', '#f8df72', '#fcd217', '#fcc515', '#f28e16', '#fb8b05', '#d85916', '#f43e06'];
            var git_user ="shengpotxun";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style>undefined</style><!-- hexo injector body_end end --></body></html>